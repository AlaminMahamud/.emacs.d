#+TITLE: My GNU EMACS Config
#+STARTUP: overview indent inlineimages
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamp:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction

I modelled this set of files based off of the emacs-starter-kit at https://github.com/eschulte/emacs24-starter-kit.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Md. Alamin Mahamud")
  (setq user-mail-address "alamin.ineedahelp@gmail.com")
#+END_SRC

* A Secure Emacs Environment
#+BEGIN_SRC shell :exports none
python -m pip install --user certifi
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;  (if (fboundp 'gnutls-available-p)
;;      (fmakunbound 'gnutls-available-p))

(require 'cl)
(setq tls-checktrust t)

(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string "python -m certifi")))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))

;; Test the settings by using the following code snippet:
;;  (let ((bad-hosts
;;         (loop for bad
;;               in `("https://wrong.host.badssl.com/"
;;                    "https://self-signed.badssl.com/")
;;               if (condition-case e
;;                      (url-retrieve
;;                       bad (lambda (retrieved) t))
;;                    (error nil))
;;               collect bad)))
;;    (if bad-hosts
;;        (error (format "tls misconfigured; retrieved %s ok" bad-hosts))
;;      (url-retrieve "https://badssl.com"
;;                    (lambda (retrieved) t))))
#+END_SRC
* Previous customizations

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat init-dir "custom.el"))

  (load custom-file :noerror)
#+END_SRC

* Installing use-package
** Setup
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

Because the default setting for package-archives is to use the HTTP access to the GNU archive, I set the variable to `nil` before adding the HTTPS variants.
#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "https://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))

;; Add marmalade to package repos
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.
#+BEGIN_SRC emacs-lisp
(package-initialize)

(unless (and (file-exists-p "~/.emacs.d/elpa/archives/gnu")
             (file-exists-p "~/.emacs.d/elpa/archives/melpa")
             (file-exists-p "~/.emacs.d/elpa/archives/melpa-stable"))
  (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing packages will be installed. The packages-install function deals with this check and takes care of any loading of the packages.
#+BEGIN_SRC emacs-lisp
  (defun packages-install (&rest packages)
    (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (unless (package-installed-p name)
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC

** The Package
#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa))

)

(condition-case nil
    (init--install-packages)
  (error
   (package-refresh-contents)
   (init--install-packages)))
#+END_SRC
* Moving Around
** bm
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("C-c =" . bm-toggle)
         ("C-c [" . bm-previous)
         ("C-c ]" . bm-next))) 
#+END_SRC
** counsel | swiper | ivy
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :ensure t
  :bind
  (("M-x" . counsel-M-x)
   ("M-y" . counsel-yank-pop)
   :map ivy-minibuffer-map
   ("M-y" . ivy-next-line)))

 (use-package swiper
   :pin melpa-stable
   :diminish ivy-mode
   :ensure t
   :bind*
   (("C-s" . swiper)
    ("C-c C-r" . ivy-resume)
    ("C-x C-f" . counsel-find-file)
    ("C-c h f" . counsel-describe-function)
    ("C-c h v" . counsel-describe-variable)
    ("C-c i u" . counsel-unicode-char)
    ("M-i" . counsel-imenu)
    ("C-c g" . counsel-git)
    ("C-c j" . counsel-git-grep)
    ("C-c k" . counsel-ag)
    ("C-c l" . scounsel-locate))
   :config
   (progn
     (ivy-mode 1)
     (setq ivy-use-virtual-buffers t)
     (define-key read-expression-map (kbd "C-r") #'counsel-expression-history)
     (ivy-set-actions
      'counsel-find-file
      '(("d" (lambda (x) (delete-file (expand-file-name x)))
         "delete"
         )))
     (ivy-set-actions
      'ivy-switch-buffer
      '(("k"
         (lambda (x)
           (kill-buffer x)
           (ivy--reset-state ivy-last))
         "kill")
        ("j"
         ivy--switch-buffer-other-window-action
         "other window")))))

(use-package counsel-projectile
  :ensure t
  :config
  (counsel-projectile-on))

(use-package ivy-hydra :ensure t)
#+END_SRC
** Kill this buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC
** Mousewheel scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+END_SRC
* discover-ability
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC

* Environment
#+BEGIN_SRC emacs-lisp
(if (or
     (eq system-type 'darwin)
     (eq system-type 'berkeley-unix))
    (setq system-name (car (split-string system-name "\\."))))

(setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
(push "/usr/local/bin" exec-path)

;; /usr/libexec/java_home
;;(setenv "JAVA_HOME" "/Library/Java/JavaVirtualMachines/jdk1.8.0_05.jdk/Contents/Home")
#+END_SRC

* GUI
** Turn off mouse interface early in startup to avoid momentary display..
#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Keyboard
#+BEGIN_SRC emacs-lisp
(setq mac-option-modifier 'none)
(setq mac-command-modifier 'meta)
(setq ns-function-modifier 'hyper)
#+END_SRC
** Move to trash when deleting stuff and write backup files to own directory
#+BEGIN_SRC emacs-lisp
;; Backup settings
(defvar --backup-directory (concat init-dir "backups"))

(if (not (file-exists-p --backup-directory))
    (make-directory --backup-directory t))

(setq backup-directory-alist `(("." . ,--backup-directory)))
(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )
  (setq delete-by-moving-to-trash t
        trash-directory "~/.Trash/emacs")

  (setq backup-directory-alist `(("." . ,(expand-file-name
                                          (concat init-dir "backups")))))
#+END_SRC
** Don't open files from the workspace in a new frame
#+BEGIN_SRC emacs-lisp
(setq ns-pop-up-frames nil)
#+END_SRC
** Spellchecking
#+BEGIN_SRC emacs-lisp
(defun spell-buffer-dutch ()
  (interactive)
  (ispell-change-dictionary "nl_NL")
  (flyspell-buffer))

(defun spell-buffer-english ()
  (interactive)
  (ispell-change-dictionary "en_US")
  (flyspell-buffer))

(use-package ispell
  :config
  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  ;; (setq ispell-program-name "aspell"
  ;;       ispell-extra-args '("--sug-mode=ultra"))
  :bind (("C-c N" . spell-buffer-dutch)
         ("C-c n" . spell-buffer-english)))
  
#+END_SRC
** Find out what face is used, so you can customize it :)
#+BEGIN_SRC emacs-lisp
;;; what-face to determine the face at the current point
(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property (point) 'read-face-name)
                  (get-char-property (point) 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC
** Windows management
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (global-set-key (kbd "C-x o") 'ace-window))

(use-package ace-jump-mode
  :ensure t
  :config
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode))
#+END_SRC
** Misc Stuff
#+BEGIN_SRC emacs-lisp
;; Custom binding for magit-status
  (use-package magit
    :config
    (global-set-key (kbd "C-c m") 'magit-status))

  (setq inhibit-startup-message t)
;;  (global-linum-mode)

  (defun iwb ()
    "indent whole buffer"
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max)))

  (global-set-key (kbd "C-c n") 'iwb)

  (electric-pair-mode t)
#+END_SRC
* Look and feel
#+BEGIN_SRC emacs-lisp
 (use-package arjen-grey-theme
   :ensure t
   :config
   (load-theme 'arjen-grey t))

 ;; (use-package base16-theme
 ;;   :ensure t
 ;;   :config
 ;;   (load-theme 'base16-materia))

(if (or (eq system-type 'darwin)(eq system-type 'gnu/linux) )
    (set-face-attribute 'default nil :font "Hack-16")
  (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 110))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :ensure t)

(defun live-coding ()
  (interactive)
  (set-face-attribute 'default nil :font "Hack-18")
  (add-hook 'prog-mode-hook 'command-log-mode)
  ;;(add-hook 'prog-mode-hook (lambda () (focus-mode 1)))
  )

(defun normal-coding ()
  (interactive)
  (set-face-attribute 'default nil :font "Hack-14")
  (add-hook 'prog-mode-hook 'command-log-mode)
  ;;(add-hook 'prog-mode-hook (lambda () (focus-mode 1)))
  )
#+END_SRC
#+BEGIN_SRC emacs-lisp
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;   (use-package all-the-icons
;;     :ensure t)
#+END_SRC
disable-beep
#+BEGIN_SRC emacs-lisp
;; http://stackoverflow.com/questions/11679700/emacs-disable-beep-when-trying-to-move-beyond-the-end-of-the-document
(defun my-bell-function ())

(setq ring-bell-function 'my-bell-function)
(setq visible-bell nil)
#+END_SRC

* Project mappings
#+BEGIN_SRC emacs-lisp
;; ;;; Setup perspectives, or workspaces, to switch between
;; (use-package perspective
;;   :ensure t
;;   :config
;;   ;; Enable perspective mode
;;   (persp-mode t)
;;   (defmacro custom-persp (name &rest body)
;;     `(let ((initialize (not (gethash ,name perspectives-hash)))
;;            (current-perspective persp-curr))
;;        (persp-switch ,name)
;;        (when initialize ,@body)
;;        (setq persp-last current-perspective)))

;;   ;; Jump to last perspective
;;   (defun custom-persp-last ()
;;     (interactive)
;;     (persp-switch (persp-name persp-last)))

;;   (define-key persp-mode-map (kbd "C-x p -") 'custom-persp-last)

;;   (defun custom-persp/emacs ()
;;     (interactive)
;;     (custom-persp "emacs"
;;                   (find-file (concat init-dir "init.el"))))

;;   (define-key persp-mode-map (kbd "C-x p e") 'custom-persp/emacs)

;;   (defun custom-persp/qttt ()
;;     (interactive)
;;     (custom-persp "qttt"
;;                   (find-file "/Users/arjen/BuildFunThings/Projects/Clojure/Game/qttt/project.clj")))

;;   (define-key persp-mode-map (kbd "C-x p q") 'custom-persp/qttt)

;;   (defun custom-persp/trivia ()
;;     (interactive)
;;     (custom-persp "trivia"
;;                   (find-file "/Users/arjen/BuildFunThings/Projects/Clojure/trivia/project.clj")))

;;   (define-key persp-mode-map (kbd "C-x p t") 'custom-persp/trivia)

;;   (defun custom-persp/mail ()
;;     (interactive)
;;     (custom-persp "mail"
;;                   (mu4e)))

;;   (define-key persp-mode-map (kbd "C-x p m") 'custom-persp/mail)
;;   )

#+END_SRC

* Writing
** Publishing
#+BEGIN_SRC emacs-lisp
(use-package request
:ensure t)
#+END_SRC

You will need an external library from Github Now for the leanpub-export
#+BEGIN_SRC emacs-lisp
;;(add-to-list 'load-path (expand-file-name (concat init-dir "ox-leanpub")))
;;(load-library "ox-leanpub")
(add-to-list 'load-path (expand-file-name (concat init-dir "ox-ghost")))
(load-library "ox-ghost")
;;; http://www.lakshminp.com/publishing-book-using-org-mode

;;(defun leanpub-export ()
;;  "Export buffer to a Leanpub book."
;;  (interactive)
;;  (if (file-exists-p "./Book.txt")
;;      (delete-file "./Book.txt"))
;;  (if (file-exists-p "./Sample.txt")
;;      (delete-file "./Sample.txt"))
;;  (org-map-entries
;;   (lambda ()
;;     (let* ((level (nth 1 (org-heading-components)))
;;            (tags (org-get-tags))
;;            (title (or (nth 4 (org-heading-components)) ""))
;;            (book-slug (org-entry-get (point) "TITLE"))
;;            (filename
;;             (or (org-entry-get (point) "EXPORT_FILE_NAME") (concat (replace-regexp-in-string " " "-" (downcase title)) ".md"))))
;;       (when (= level 1) ;; export only first level entries
;;         ;; add to Sample book if "sample" tag is found.
;;         (when (or (member "sample" tags)
;;                   ;;(string-prefix-p "frontmatter" filename) (string-prefix-p "mainmatter" filename)
;;                   )
;;           (append-to-file (concat filename "\n\n") nil "./Sample.txt"))
;;         (append-to-file (concat filename "\n\n") nil "./Book.txt")
;;         ;; set filename only if the property is missing
;;         (or (org-entry-get (point) "EXPORT_FILE_NAME")  (org-entry-put (point) "EXPORT_FILE_NAME" filename))
;;         (org-leanpub-export-to-markdown nil 1 nil)))) "-noexport")
;;  (org-save-all-org-buffers)
;;  nil
;;  nil)
;;
;;(require 'request)
;;
;;(defun leanpub-preview ()
;;  "Generate a preview of your book @ Leanpub."
;;  (interactive)
;;  (request
;;   "https://leanpub.com/clojure-on-the-server/preview.json" ;; or better yet, get the book slug from the buffer
;;   :type "POST"                                             ;; and construct the URL
;;   :data '(("api_key" . ""))
;;   :parser 'json-read
;;   :success (function*
;;             (lambda (&key data &allow-other-keys)
;;               (message "Preview generation queued at leanpub.com.")))))
#+END_SRC
** Word wrapping
please wrap text around when in text-modes. Also enable flyspell to catch nasty writing errors.
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda ()
                     (flyspell-mode 1)
                     (visual-line-mode  1))))
#+END_SRC
** Markdown support
Markdown is a great way to write documentation, not as good as org-mode of course, but generally accepted as a standard.
not as good as org-mode of course, but generally accepted as a standard.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
:ensure t)
#+END_SRC

** HTMLize buffers
#+BEGIN_SRC emacs-lisp
(use-package htmlize
:ensure t)
#+END_SRC

** Exports
Export ORG code fragments with a particular theme.

#+BEGIN_SRC emacs-lisp
(defun my/with-theme (theme fn &rest args)
  (let ((current-themes custom-enabled-themes))
    (mapcar #'disable-theme custom-enabled-themes)
    (load-theme theme t)
    (let ((result (apply fn args)))
      (mapcar #'disable-theme custom-enabled-themes)
      (mapcar (lambda (theme) (load-theme theme t)) current-themes)
      result)))
;;(advice-add #'org-export-to-file :around (apply-partially #'my/with-theme 'arjen-grey))
;;(advice-add #'org-export-to-buffer :around (apply-partially #'my/with-theme 'arjen-grey))
#+END_SRC
* Programming
* Org-Mode
* Password Management
#+BEGIN_SRC emacs-lisp
(use-package pass
:ensure t)

(use-package auth-password-store
  :ensure t
  :config
  (auth-pass-enable))
#+END_SRC
* Email
#+BEGIN_SRC emacs-lisp
(require 'mu4e)
(defun my-render-html-message ()
  (let ((dom (libxml-parse-html-region (point-min) (point-max))))
    (erase-buffer)
    (shr-insert-document dom)
    (goto-char (point-min))))

(setq mu4e-html2text-command 'my-render-html-message)
;;(setq mu4e-html2text-command "html2text -utf8 -width 72")

;; I want my format=flowed thank you very much
;; mu4e sets up visual-line-mode and also fill (M-q) to do the right thing
;; each paragraph is a single long line; at sending, emacs will add the
;; special line continuation characters.
(setq mu4e-compose-format-flowed t)

;; every new email composition gets its own frame! (window)
(setq mu4e-compose-in-new-frame t)

;; Show addresses, not just names
(setq mu4e-view-show-addresses 't)

(setq mu4e-view-show-images t
      mu4e-show-images t
      mu4e-view-image-max-width 800)

;; default
(setq mu4e-maildir (expand-file-name "~/Maildir"))

(setq mu4e-drafts-folder "/Personal/Drafts")
(setq mu4e-sent-folder   "/Personal/Sent Items")
(setq mu4e-trash-folder  "/Personal/Trash")

;; don't save message to Sent Messages, GMail/IMAP will take care of this
(setq mu4e-sent-messages-behavior 'sent)

;; setup some handy shortcuts
(setq mu4e-maildir-shortcuts
      '(("/Personal/INBOX"             . ?i)
        ("/Personal/Sent Items" . ?s)
        ("/Personal/Trash"     . ?t)))

;; allow for updating mail using 'U' in the main view:
(setq mu4e-get-mail-command "offlineimap")

;; something about ourselves
;; I don't use a signature...
(setq
 user-mail-address "alamin.ineedahelp@gmail.com"
 user-full-name  "Md. Alamin Mahamud"
 ;; message-signature
 ;;  (concat
 ;;    "Full Stack Engineer\n"
 ;;    "https://alaminmahamud.github.io\n")
 )

;; sending mail -- replace USERNAME with your gmail username
;; also, make sure the gnutls command line utils are installed
;; package 'gnutls-bin' in Debian/Ubuntu, 'gnutls' in Archlinux.

(require 'smtpmail)

(setq message-send-mail-function 'smtpmail-send-it
      starttls-use-gnutls t
      smtpmail-starttls-credentials
      '(("smtp.fastmail.com" 587 nil nil))
      smtpmail-auth-credentials
      (expand-file-name "~/.authinfo.gpg")
      smtpmail-default-smtp-server "smtp.fastmail.com"
      smtpmail-smtp-server "smtp.fastmail.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)

#+END_SRC

* Elfeed
#+BEGIN_SRC emacs-lisp
(setq elfeed-db-directory "~/.emacs.d/elfeeddb")


(defun elfeed-mark-all-as-read ()
  (interactive)
  (mark-whole-buffer)
  (elfeed-search-untag-all-unread))

;; code to add and remove a starred tag to elfeed article
;; based on http://matt.hackinghistory.ca/2015/11/22/elfeed/

;; add a star
(defun bjm/elfeed-star ()
  "Apply starred to all selected entries."
  (interactive )
  (let* ((entries (elfeed-search-selected))
         (tag (intern "starred")))

    (cl-loop for entry in entries do (elfeed-tag entry tag))
    (mapc #'elfeed-search-update-entry entries)
    (unless (use-region-p) (forward-line))))

;; remove a start
(defun bjm/elfeed-unstar ()
  "Remove starred tag from all selected entries."
  (interactive )
  (let* ((entries (elfeed-search-selected))
         (tag (intern "starred")))

    (cl-loop for entry in entries do (elfeed-untag entry tag))
    (mapc #'elfeed-search-update-entry entries)
    (unless (use-region-p) (forward-line))))

;; face for starred articles
(defface elfeed-search-starred-title-face
  '((t :foreground "#f77"))
  "Marks a starred Elfeed entry.")

(push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)

;;functions to support syncing .elfeed between machines
;;makes sure elfeed reads index from disk before launching
(defun bjm/elfeed-load-db-and-open ()
  "Wrapper to load the elfeed db from disk before opening"
  (interactive)
  (elfeed-db-load)
  (elfeed)
  (elfeed-search-update--force))

;;write to disk when quiting
(defun bjm/elfeed-save-db-and-bury ()
  "Wrapper to save the elfeed db to disk before burying buffer"
  (interactive)
  (elfeed-db-save)
  (quit-window))

(use-package elfeed
  :ensure t
  :bind (:map elfeed-search-mode-map
              ("q" . bjm/elfeed-save-db-and-bury)
              ("Q" . bjm/elfeed-save-db-and-bury)
              ("*" . bjm/elfeed-star)
              ("M" . bjm/elfeed-unstar)
              )
  )

;; (defalias 'elfeed-toggle-star
;;   (elfeed-expose #'elfeed-search-toggle-all 'star))

;; (use-package elfeed-goodies
;;   :ensure t
;;   :config
;;   (elfeed-goodies/setup))


(use-package elfeed-org
  :ensure t
  :config
  (setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
  (elfeed-org)
  )
#+END_SRC
