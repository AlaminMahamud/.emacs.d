#+TITLE: My GNU EMACS Config
#+AUTHOR: Md. Alamin Mahamud
#+EMAIL: alamin.ineedahelp@gmail.com
#+STARTUP: overview indent inlineimages
#+OPTIONS: H:5 num:nil tags:nil toc:nil timestamp:t
#+LAYOUT: post
#+DESCRIPTION: Loading emacs configuration using org-babel
#+TAGS: emacs
#+CATEGORIES: editing

* Introduction

I modelled this set of files based off of the emacs-starter-kit at https://github.com/eschulte/emacs24-starter-kit.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Md. Alamin Mahamud")
  (setq user-mail-address "alamin.ineedahelp@gmail.com")
#+END_SRC

* A Secure Emacs Environment
#+BEGIN_SRC shell :exports none
python -m pip install --user certifi
#+END_SRC

#+BEGIN_SRC emacs-lisp
;;  (if (fboundp 'gnutls-available-p)
;;      (fmakunbound 'gnutls-available-p))

(require 'cl)
(setq tls-checktrust t)

(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string "python -m certifi")))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))

;; Test the settings by using the following code snippet:
;;  (let ((bad-hosts
;;         (loop for bad
;;               in `("https://wrong.host.badssl.com/"
;;                    "https://self-signed.badssl.com/")
;;               if (condition-case e
;;                      (url-retrieve
;;                       bad (lambda (retrieved) t))
;;                    (error nil))
;;               collect bad)))
;;    (if bad-hosts
;;        (error (format "tls misconfigured; retrieved %s ok" bad-hosts))
;;      (url-retrieve "https://badssl.com"
;;                    (lambda (retrieved) t))))
#+END_SRC
* Previous customizations

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat init-dir "custom.el"))

  (load custom-file :noerror)
#+END_SRC

* Modernizing Emacs
With a long history of working on small machines without gigabytes of RAM, we might as well always be the beast it has always dreamed.

First, let's increase the cache before starting garbage collection:
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 50000000)
#+END_SRC
Remove the warnings from the GnuTLS lib when using HTTPS ... increase the minimum prime bits size..
#+BEGIN_SRC emacs-lisp
(setq gnutls-min-prime-bits 4096)
#+END_SRC
* Installing Package Initialization
** Package Manager Setup
#+BEGIN_SRC emacs-lisp
(require 'package)
#+END_SRC

Because the default setting for package-archives is to use the HTTP access to the GNU archive, I set the variable to `nil` before adding the HTTPS variants.
#+BEGIN_SRC emacs-lisp
(defvar gnu '("gnu" . "https://elpa.gnu.org/packages/"))
(defvar melpa '("melpa" . "https://melpa.org/packages/"))
(defvar melpa-stable '("melpa-stable" . "https://stable.melpa.org/packages/"))

;; Add marmalade to package repos
(setq package-archives nil)
(add-to-list 'package-archives melpa-stable t)
(add-to-list 'package-archives melpa t)
(add-to-list 'package-archives gnu t)
#+END_SRC

Initialize the archive and refresh the contents in case there is no cached archive.
#+BEGIN_SRC emacs-lisp
(package-initialize)

(unless (and (file-exists-p "~/.emacs.d/elpa/archives/gnu")
             (file-exists-p "~/.emacs.d/elpa/archives/melpa")
             (file-exists-p "~/.emacs.d/elpa/archives/melpa-stable"))
  (package-refresh-contents))
#+END_SRC

At each load the package list will be evaluated and any missing packages will be installed. The packages-install function deals with this check and takes care of any loading of the packages.
#+BEGIN_SRC emacs-lisp
  (defun packages-install (&rest packages)
    (message "running packages-install")
    (mapc (lambda (package)
            (let ((name (car package))
                  (repo (cdr package)))
              (unless (package-installed-p name)
                (let ((package-archives (list repo)))
                  (package-initialize)
                  (package-install name)))))
          packages)
    (package-initialize)
    (delete-other-windows))
#+END_SRC

** use-package
#+BEGIN_SRC emacs-lisp
;; Install extensions if they're missing
(defun init--install-packages ()
  (message "Lets install some packages")
  (packages-install
   ;; Since use-package this is the only entry here
   ;; ALWAYS try to use use-package!
   (cons 'use-package melpa))

)

(condition-case nil
    (init--install-packages)
  (error
   (package-refresh-contents)
   (init--install-packages)))
#+END_SRC
** init file support
Load up a collection of enhancement to Emacs Lisp, including [[https://github.com/magnars/dash.el][dash]], [[https://github.com/magnars/s.el][s]] for string manipulation, and [[https://github.com/rejeep/f.el][f]] for file manipulation.
#+BEGIN_SRC emacs-lisp
(require 'cl)

(use-package dash
:ensure t
:config (eval-after-load "dash" '(dash-enable-font-lock)))

(use-package s
:ensure t)

(use-package f
:ensure t)
#+END_SRC

** tabs vs spaces
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
(setq tab-width 2)
#+END_SRC
Make tab key do indent first then completion
#+BEGIN_SRC emacs-lisp
(setq-default tab-always-indent 'complete)
#+END_SRC
** TODO Encrypting Files
learn from =Howard Abrams=
** Misc variable settings
#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
Fix the scrolling to keep point in the center
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 10000
        scroll-preserve-screen-position t)
#+END_SRC
Don't know why this important?
#+BEGIN_SRC emacs-lisp
(setq disabled-command-function nil)
#+END_SRC


* Editing
** Mark ring
#+BEGIN_SRC emacs-lisp
  (setq global-mark-ring-max 5000   ; increase mark ring to contains 5000 entries
        mark-ring-max 5000          ; increase kill to contains 5000 entries
        mode-require-final-newline t; add a newline to end of file
        )
#+END_SRC
** Tab
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC
** Coding System
#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC
** Killing
#+BEGIN_SRC emacs-lisp
(setq
 kill-ring-max 5000 ; increase kill-ring capacity
 kill-whole-line t  ; if NIL, kill whole line and move the next line up
 )
#+END_SRC
** TODO Misc
#+BEGIN_SRC emacs-lisp
(delete-selection-mode)
(global-set-key (kbd "RET") 'newline-and-indent)
#+END_SRC

Show important whitespace in diff-mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'diff-mode-hook
            (lambda ()
              (setq-local
               whitespace-style
               '(
                 face
                 tabs
                 spaces
                 space-mark
                 trailing
                 indentation::space
                 indentation::tab
                 newline
                 newline-mark))
              (whitespace-mode 1)))
#+END_SRC

Move to the first non-whitespace character of that line.
#+BEGIN_SRC emacs-lisp
   (defun prelude-move-beginning-of-line (arg)
     "Move point back to indentation of beginning of line.

   Move point to the first non-whitespace character on this line.
   If point is already there, move to the beginning of the line.
   Effectively toggle between the first non-whitespace character and
   the beginning of the line.

   If ARG is not nil or 1, move forward ARG - 1 lines first. If
   point reaches the beginning or end of the buffer, stop there."
     (interactive "^p")
     (setq arg (or arg 1))

     ;; Move lines first
     (when (/= arg 1)
       (let ((line-move visual nil))
         (forward-line (1- arg))))

     (let ((orig-point (point)))
       (back-to-indentation)
       (when (= origi-point (point))
         (move-beginning-of-line 1))))

  (global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single
  line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
  line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))

#+END_SRC

Kill a line including whitespace characters until next non-whitespace char of next line
#+BEGIN_SRC emacs-lisp
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
#+END_SRC

taken from prelude-editor.el
automatically indenting yanked text in programming-modes
#+BEGIN_SRC emacs-lisp
;; prelude-core.el
(defun prelude-duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (pcase-let* ((origin (point))
               (`(,beg . ,end) (prelude-get-positions-of-line-or-region))
               (region (buffer-substring-no-properties beg end)))
    (-dotimes arg
      (lambda (n)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point))))
    (goto-char (+ origin (* (length region) arg) arg))))

;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))
;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list)

(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)

;; add duplicate line function from Prelude
;; taken from prelude-core.el
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line
or region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))

(defun kill-default-buffer ()
  "Kill the currently active buffer -- set to C-x k so that users are not asked which buffer they want to kill."
  (interactive)
  (let (kill-buffer-query-functions) (kill-buffer)))

(global-set-key (kbd "C-x k") 'kill-default-buffer)

;; smart openline
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode.
With a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))

(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(global-set-key (kbd "C-o") 'prelude-smart-open-line)
(global-set-key (kbd "M-o") 'open-line)
#+END_SRC

** duplicate-thing
_Author_      : ongaeshi, =ongaeshi0621@gmail.com=

_Homepage_    : [[https://github.com/ongaeshi/duplicate-thing][Github]]

_Features_    : Easy duplicate line or region, with comment out
- Duplicate current line
- Duplicate a selection when selection is active.
- Only C-u, replicate, comment out the range.
- Numerical prefix is specified as 'C-u 5': do multiple times repeatedly.

_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package duplicate-thing
:ensure t
:config
(require 'duplicate-thing)
(global-set-key (kbd "M-c") 'duplicate-thing))
#+END_SRC

_Usage_       : If point is on a line, the command duplicates the current line. If region is active, duplicates region instead.

** volatile-highlights
_Author_      : Keitalo Miyazaki, =keitaro.miyazaki@gmail.com=
_Homepage_    : [[http://www.emacswiki.org/emacs/VolatileHighlights][Emacswiki]]
_Features_    : 'Volatile Highlights' highlights changes to the buffer caused by commands such as ‘undo’, ‘yank’/’yank-pop’, etc. The highlight disappears at the next command. The highlighting gives useful visual feedback for what your operation actually changed in the buffer.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
:ensure t
:config
(require 'volatile-highlights)
(volatile-highlights-mode t))
#+END_SRC
_Usage_       : When you yank (paste) something, the yanked region will be highlighted.

** smartparens
_Author_  : Matus Goljer, =matus.goljer@gmail.com=
_Homepage_: [[https://github.com/Fuco1/smartparens][Github]]
_Features_: Minor mode for Emacs that deals with parens pairs and tries to be smart about it.
 - It can automatically insert pairs
[[https://github.com/Fuco1/smartparens/raw/master/images/smartparens-insert.gif]]
- wrap, unwrap and rewrap pairs
[[https://github.com/Fuco1/smartparens/raw/master/images/smartparens-wrap.gif]]
- expand and contract pairs
[[https://github.com/Fuco1/smartparens/raw/master/images/smartparens-slurp.gif]]
- navigate pairs
[[https://github.com/Fuco1/smartparens/raw/master/images/smartparens-navigate.gif]]
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package smartparens-config
:ensure smartparens
:config
(progn
(show-smartparens-global-mode t)))

(add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
(add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
(bind-keys
 :map smartparens-mode-map
 ("C-M-a" . sp-beginning-of-sexp)
 ("C-M-e" . sp-end-of-sexp)

 ("C-<down>" . sp-down-sexp)
 ("C-<up>"   . sp-up-sexp)
 ("M-<down>" . sp-backward-down-sexp)
 ("M-<up>"   . sp-backward-up-sexp)

 ("C-M-f" . sp-forward-sexp)
 ("C-M-b" . sp-backward-sexp)

 ("C-M-n" . sp-next-sexp)
 ("C-M-p" . sp-previous-sexp)

 ("C-S-f" . sp-forward-symbol)
 ("C-S-b" . sp-backward-symbol)

 ("C-<right>" . sp-forward-slurp-sexp)
 ("M-<right>" . sp-forward-barf-sexp)
 ("C-<left>"  . sp-backward-slurp-sexp)
 ("M-<left>"  . sp-backward-barf-sexp)

 ("C-M-t" . sp-transpose-sexp)
 ("C-M-k" . sp-kill-sexp)
 ("C-k"   . sp-kill-hybrid-sexp)
 ("M-k"   . sp-backward-kill-sexp)
 ("C-M-w" . sp-copy-sexp)
 ("C-M-d" . delete-sexp)

 ("M-<backspace>" . backward-kill-word)
 ("C-<backspace>" . sp-backward-kill-word)
 ([remap sp-backward-kill-word] . backward-kill-word)

 ("M-[" . sp-backward-unwrap-sexp)
 ("M-]" . sp-unwrap-sexp)

 ("C-x C-t" . sp-transpose-hybrid-sexp)

 ("C-c ("  . wrap-with-parens)
 ("C-c ["  . wrap-with-brackets)
 ("C-c {"  . wrap-with-braces)
 ("C-c M-'"  . wrap-with-single-quotes)
 ("C-c \"" . wrap-with-double-quotes)
 ("C-c _"  . wrap-with-underscores)
 ("C-c `"  . wrap-with-back-quotes))
#+END_SRC
** clean-aindent-mode
_Author_  :
_Homepage_:
_Features_:
When you press RET to create a newline and got indented by eletric-indent-mode, you have appropriate whitespace for indenting. But, if you leave the line blank and move to the next line, the whitespace becomes useless. This package helps clean up unused whitespace.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
:ensure t
:config
(require 'clean-aindent-mode))

(add-hook 'prog-mode-hook 'clean-aindent-mode)
#+END_SRC
_Usage_:
Automatically cleanup whitespaced on moving up/down
** undo-tree
_Author_:
_Homepage_:
_Features_:
undo-tree allows you to visual the whole history of your editing in a
tree. It also provides regular undo/redo behaviours in other
editors. undo-tree can even provide a diff between two different
states. Highly recommended.
[[https://tuhdo.github.io/static/part3/undo-tree.jpg]]
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
:ensure t
:config
(require 'undo-tree)
(global-undo-tree-mode))
#+END_SRC
_Usage_:
undo =C-/=
redo =C-_=
see undo tree =C-x u=
** yasnippet
_Author_:
_Homepage_: [[https://github.com/joaotavora/yasnippet][Github]]
_Features_: YASnippet is a template system for Emacs. It allows you to type an abbreviation and automatically expand it into function templates. Bundled language templates include: C, C++, C#, Perl, Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is inspired from TextMate's syntax, you can even import most TextMate templates to YASnippet. Watch a demo on YouTube.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
:ensure t
:config
(require 'yasnippet)
(yas-global-mode 1))
#+END_SRC
_usage_:
** Origami
_author_:
_homepage_: [[https://github.com/gregsexton/origami.el]]
_features_:
text-folding minor mode
[[https://camo.githubusercontent.com/c5f625fcf6bdeda0381ee5370026c7027433d1d7/687474703a2f2f7777772e67726567736578746f6e2e6f72672f696d616765732f6f726967616d692d73637265656e2e706e67]]

_installation_:
#+BEGIN_SRC emacs-lisp
  (use-package origami
  :ensure t
  :config
  (require 'origami)
  (add-hook 'prog-mode-hook 'origami-mode)
  (define-key origami-mode-map (kbd "C-c f") 'origami-recursively-toggle-node)
  (define-key origami-mode-map (kbd "C-c F") 'origami-toggle-all-nodes))
#+END_SRC
_usage_:

** Rebox2
#+BEGIN_SRC emacs-lisp
(use-package rebox2
:ensure t
:config
(rebox-mode) 1)
#+END_SRC

** dtrt-indent
#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
:init
  (dtrt-indent-mode 1)
  (setq dtrt-indent-verbosity 0))
#+END_SRC
** ws-butler
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
:ensure t
  :init
  (add-hook 'prog-mode-hook 'ws-butler-mode)
  (add-hook 'text-mode 'ws-butler-mode)
  (add-hook 'fundamental-mode 'ws-butler-mode))
#+END_SRC
** comment-dwim-2
_author_:
_homepage_: [[https://github.com/remyferre/comment-dwim-2]]
_features_:
comment-dwim-2 is a replacement for the Emacs' built-in command comment-dwim which includes more comment features, including:

+ commenting/uncommenting the current line (or region, if active)
+ inserting an inline comment
+ killing the inline comment
+ reindenting the inline comment
#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
  :ensure t
  :config
  (global-set-key (kbd "M-;") 'comment-dwim-2))
#+END_SRC

** anzu mode
(use-package anzu
:ensure t
  :init
  (global-anzu-mode)
  (global-set-key (kbd "M-%") 'anzu-query-replace)
  (global-set-key (kbd "C-M-%") 'anzu-query-replace-regexp))
** iedit
_author_:
_homepage_: https://github.com/victorhge/iedit
_features_:
edit one occurrence of some text in a buffer (possibly narrowed) or region, and simultaneously have other occurrences edited in the same way, with visual feedback as you type.
#+BEGIN_SRC emacs-lisp
(use-package iedit
  :bind (("C-;" . iedit-mode))
  :init
  (setq iedit-toggle-key-default nil))
#+END_SRC
_usage_:
Normal work flow of Iedit mode is like:

- Move to certain point and press C-; (The default key binding). All occurrences of a symbol, string or a region in the buffer are highlighted corresponding to the thing under the point, current mark and prefix argument. Refer to the document of `iedit-mode’ for details.
- Edit one of the occurrences The change is applied to other occurrences simultaneously.
- Finish - by pressing C-; again
** function-args
#+BEGIN_SRC emacs-lisp
(use-package function-args
:ensure t
:config
(require 'function-args)
(fa-config-default)
)
#+END_SRC
* Convenience
** auto-revert
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode)
#+END_SRC
** Workgroups2
Create your workspace in emacs

_Features_:
Workgroups is a session manager for Emacs.
- It saves all your opened buffers, their locations and sizes on disk
  to restore later.
- create several workspaces.

You can also restore buffers such as org-agenda, shell, magit-status,
help.
_Installation_:
#+BEGIN_SRC emacs-lisp
  (use-package workgroups2
  :ensure t
  :config
  (require 'workgroups2)

  ;; Change prefix key (before activating WG)
  (setq wg-prefix-key (kbd "C-c z"))
  ;; Change workgroups session file
  (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
  ;; What to do on Emacs exit / workgroups-mode exit?
  (setq wg-emacs-exit-save-behavior           'save)
  (setq wg-workgroups-mode-exit-save-behavior 'save)

  ;; Mode Line Changes
  ;; Display workgroups in Mode Line?
  (setq wg-mode-line-display-on t)
  (setq wg-flag-modified t)
  (setq wg-mode-line-decor-left-brace "["
        wg-mode-line-decor-right-brace "]"
        wg-mode-line-decor-divider ":")
  (workgroups-mode 1))
#+END_SRC
** hippe Expand
hippe-expand is a better version of dabbrev-expand
while dabbrev-expand searches for words you already types in current
buffers and other buffers, hippie-expand includes more sources
such as filenames, kill ring...
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
(setq
hippie-expand-try-functions-list
'(try-expand-dabbrev ;; Try to expand word "dynamically", searching the current buffer.
   try-expand-dabbrev-all-buffers ;; Try to expand word "dynamically", searching all other buffers.
   try-expand-dabbrev-from-kill ;; Try to expand word "dynamically", searching the kill ring.
   try-complete-file-name-partially ;; Try to complete text as a file name, as many characters as unique.
   try-complete-file-name ;; Try to complete text as a file name.
   try-expand-all-abbrevs ;; Try to expand word before point according to all abbrev tables.
   try-expand-list ;; Try to complete the current line to an entire line in the buffer.
   try-expand-line ;; Try to complete the current line to an entire line in the buffer.
   try-complete-lisp-symbol-partially ;; Try to complete as an Emacs Lisp symbol, as many characters as unique.
   try-complete-lisp-symbol) ;; Try to complete word as an Emacs Lisp symbol.
)
#+END_SRC
** Highlight current line
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode)
#+END_SRC
** Ibuffer
#+BEGIN_SRC emacs-lisp
(setq ibuffer-use-other-window t) ;; always display ibuffer in another window
#+END_SRC
** Linum
#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'linum-mode) ;; enable linum only in programming modes
#+END_SRC
** useless whitespace
#+BEGIN_SRC emacs-lisp
;; whenever you create useless whitespace, the whitespace is highlighted
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)

#+END_SRC

** easier window navigation
#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
#+END_SRC
** company
_Author_:
_Homepage_:
_Features_:
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package company
:ensure t
:config
(add-hook 'after-init-hook 'global-company-mode))
#+END_SRC
_usage_:
** expand-region
_Author_:
_Homepage_:
_Features_:
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package expand-region
:ensure t
:config
(require 'expand-region)
(global-set-key (kbd "M-m") 'er/expand-region))
#+END_SRC
_usage_:
** ibuffer-vc
_Author_:
_Homepage_:
_Features_:
_Installation_:
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :ensure t
    :config
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode 'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))
  (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process))))

#+END_SRC
_usage_:
** projectile
_Author_:
_Homepage_:
_Features_:
project interaction lib
- jump to a file in project
- jump to a directory in a project
- jump to file in a dir
- jump to a project buffer
- jump to a test in project
- toggle between code and its test
- jump to recently visited files in the project
- switch between projects you have worked on
- kill all project buffers
- replace in project
- multi-occur in project buffers
- grep in project
- regenerate project etags or gtags
- visit project in dired
- run make in a project with a single key chord
- check for dirty repos
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package projectile
:ensure t
:config
(projectile-global-mode))
#+END_SRC
_usage_:
** Kill this buffer
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC
** bm
Bookmarks are very useful for quickly jumping around files.
#+BEGIN_SRC emacs-lisp
(use-package bm
  :ensure t
  :bind (("C-c =" . bm-toggle)
         ("C-c [" . bm-previous)
         ("C-c ]" . bm-next)))
#+END_SRC

** Windows management
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :ensure t
  :config
  (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
  (global-set-key (kbd "C-x o") 'ace-window)
:diminish ace-window-mode)

(use-package ace-jump-mode
  :ensure t
  :config
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode))
#+END_SRC

** inhibit start message
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC
** indent whole buffer
#+BEGIN_SRC emacs-lisp

  (defun iwb ()
    "indent whole buffer"
    (interactive)
    (delete-trailing-whitespace)
    (indent-region (point-min) (point-max) nil)
    (untabify (point-min) (point-max)))

  (global-set-key (kbd "C-c n") 'iwb)

#+END_SRC
** command-log-mode
#+BEGIN_SRC emacs-lisp
(use-package command-log-mode
  :ensure t)
#+END_SRC
** zygospore
_author_: 
_homepage_: https://github.com/LouisKottmann/zygospore.el
_features_:
zygospore lets you revert C-x 1 (delete-other-window) by pressing C-x
1 again
[[https://github.com/LouisKottmann/zygospore.el/raw/master/demo.gif]]
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package zygospore
:ensure t
  :bind (("C-x 1" . zygospore-toggle-delete-other-windows)
         ("RET" .   newline-and-indent)))
#+END_SRC
_usage_:
* Helm
_Author_:
- Tamas Patrovic (original author), from 2007. At this time, Helm was named =Anything=
- rubikitch =rubikitch@ruby-lang.org=, from 2008-2011. Helm was still named =Anything=
- [[https://github.com/thierryvolpiatto][Thierry Volpiatto]] (current maintainer). =thierry.volpiatto@gmail.com=, from 2011-present. =Anything= was renamed to =Helm= during this period.
_Homepage_: [[https://github.com/emacs-helm/helm][Github]]
_Features_:
=Helm= is an incremental completion and selection narrowing framework for Emacs. It will help steer you in the right direction when you're looking for stuff in Emacs (like buffers, files, etc).
Helm is a fork of =anything.el= (originally written by Tamas Patrovic) and can be considered to be its successor. =Helm= sets out to clean up the legacy code in =anything.el= and provide a cleaner, leaner and more modular tool, that's not tied in the trap of backward compatibility.

_Installation_:
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :init
    (progn
      (require 'helm-config)
      (require 'helm-grep)
      ;; To fix error at compile:
      ;; Error (bytecomp): Forgot to expand macro with-helm-buffer in
      ;; (with-helm-buffer helm-echo-input-in-header-line)
      (if (version< "26.0.50" emacs-version)
          (eval-when-compile (require 'helm-lib)))

      (defun helm-hide-minibuffer-maybe ()
        (when (with-helm-buffer helm-echo-input-in-header-line)
          (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
            (overlay-put ov 'window (selected-window))
            (overlay-put ov 'face (let ((bg-color (face-background 'default nil)))
                                    `(:background ,bg-color :foreground ,bg-color)))
            (setq-local cursor-type nil))))

      (add-hook 'helm-minibuffer-set-up-hook 'helm-hide-minibuffer-maybe)
      ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
      ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
      ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
      (global-set-key (kbd "C-c h") 'helm-command-prefix)
      (global-unset-key (kbd "C-x c"))

      (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
      (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
      (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

      (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
      (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
      (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)

      (when (executable-find "curl")
        (setq helm-google-suggest-use-curl-p t))

      (setq helm-google-suggest-use-curl-p t
            helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
            ;; helm-quick-update t ; do not display invisible candidates
            helm-ff-search-library-in-sexp t ; search for library in `require' and `declare-function' sexp.

            ;; you can customize helm-do-grep to execute ack-grep
            ;; helm-grep-default-command "ack-grep -Hn --smart-case --no-group --no-color %e %p %f"
            ;; helm-grep-default-recurse-command "ack-grep -H --smart-case --no-group --no-color %e %p %f"
            helm-split-window-in-side-p t ;; open helm buffer inside current window, not occupy whole other window

            helm-echo-input-in-header-line t

            ;; helm-candidate-number-limit 500 ; limit the number of displayed canidates
            helm-ff-file-name-history-use-recentf t
            helm-move-to-line-cycle-in-source t ; move to end or beginning of source when reaching top or bottom of source.
            helm-buffer-skip-remote-checking t

            helm-mode-fuzzy-match t

            helm-buffers-fuzzy-matching t ; fuzzy matching buffer names when non-nil
                                          ; useful in helm-mini that lists buffers
            helm-org-headings-fontify t
            ;; helm-find-files-sort-directories t
            ;; ido-use-virtual-buffers t
            helm-semantic-fuzzy-match t
            helm-M-x-fuzzy-match t
            helm-imenu-fuzzy-match t
            helm-lisp-fuzzy-completion t
            ;; helm-apropos-fuzzy-match t
            helm-buffer-skip-remote-checking t
            helm-locate-fuzzy-match t
            helm-display-header-line nil)

      (add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

      (global-set-key (kbd "M-x") 'helm-M-x)
      (global-set-key (kbd "M-y") 'helm-show-kill-ring)
      (global-set-key (kbd "C-x b") 'helm-buffers-list)
      (global-set-key (kbd "C-x C-f") 'helm-find-files)
      (global-set-key (kbd "C-c r") 'helm-recentf)
      (global-set-key (kbd "C-h SPC") 'helm-all-mark-rings)
      (global-set-key (kbd "C-c h o") 'helm-occur)
      (global-set-key (kbd "C-c h o") 'helm-occur)

      (global-set-key (kbd "C-c h w") 'helm-wikipedia-suggest)
      (global-set-key (kbd "C-c h g") 'helm-google-suggest)

      (global-set-key (kbd "C-c h x") 'helm-register)
      ;; (global-set-key (kbd "C-x r j") 'jump-to-register)

      (define-key 'help-command (kbd "C-f") 'helm-apropos)
      (define-key 'help-command (kbd "r") 'helm-info-emacs)
      (define-key 'help-command (kbd "C-l") 'helm-locate-library)

      ;; use helm to list eshell history
      (add-hook 'eshell-mode-hook
                #'(lambda ()
                    (define-key eshell-mode-map (kbd "M-l")  'helm-eshell-history)))

  ;;; Save current position to mark ring
      (add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)

      ;; show minibuffer history with Helm
      (define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
      (define-key minibuffer-local-map (kbd "M-n") 'helm-minibuffer-history)

      (define-key global-map [remap find-tag] 'helm-etags-select)

      (define-key global-map [remap list-buffers] 'helm-buffers-list)

#+END_SRC
Helm-swoop
#+BEGIN_SRC emacs-lisp
    ;; Locate the helm-swoop folder to your path
    (use-package helm-swoop
      :ensure t
      :bind (("C-c h o" . helm-swoop)
             ("C-c s" . helm-multi-swoop-all))
      :config
      ;; When doing isearch, hand the word over to helm-swoop
      (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)

      ;; From helm-swoop to helm-multi-swoop-all
      (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)

      ;; Save buffer when helm-multi-swoop-edit complete
      (setq helm-multi-swoop-edit-save t)

      ;; If this value is t, split window inside the current window
      (setq helm-swoop-split-with-multiple-windows t)

      ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
      (setq helm-swoop-split-direction 'split-window-vertically)

      ;; If nil, you can slightly boost invoke speed in exchange for text color
      (setq helm-swoop-speed-or-color t))

    (helm-mode 1)

#+END_SRC
Helm-gtags
#+BEGIN_SRC emacs-lisp
;; this variable must be set before load helm-gtags
;; you can change to any prefix key of your choice
(setq helm-gtags-prefix-key "\C-cg")

(use-package helm-gtags
  :ensure t
  :init
  (progn
    (setq helm-gtags-ignore-case t
          helm-gtags-auto-update t
          helm-gtags-use-input-at-cursor t
          helm-gtags-pulse-at-cursor t
          helm-gtags-prefix-key "\C-cg"
          helm-gtags-suggested-key-mapping t)

    ;; Enable helm-gtags-mode in Dired so you can jump to any tag
    ;; when navigate project tree with Dired
    (add-hook 'dired-mode-hook 'helm-gtags-mode)

    ;; Enable helm-gtags-mode in Eshell for the same reason as above
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)

    ;; Enable helm-gtags-mode in languages that GNU Global supports
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'java-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    ;; key bindings
    (with-eval-after-load 'helm-gtags
      (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
      (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
      (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
      (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
      (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
      (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))))

#+END_SRC
_Usage_:
*** Exploring Large Projects with Projectile and Helm Projectile
**** Demos
- Select and open multiple files
[[http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-1.gif]]
- Open file at point anywhere
[[http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-dwim-1.gif]]
- Copy files anywhere
[[http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-copy.gif]]
- Delete files anywhere
[[http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-delete.gif]]
- Switch between current file and other files with same names but different extensions
[[http://tuhdo.github.io/static/helm-projectile/helm-projectile-find-other-file.gif]]
**** Installation and configuration
#+BEGIN_SRC emacs-lisp

    (use-package helm-projectile
      :init
      (helm-projectile-on)
      (setq projectile-completion-system 'helm)
      (setq projectile-indexing-method 'alien))))

#+END_SRC
All projectile commands has prefix =C-c p=.
**** helm-projectile, C-c p h
_Usage_:
- =helm-projectile-switch-to-buffer=
- =helm-projectile-find-file=
- =helm-projectile-switch-project=
**** Enter project portal
#+BEGIN_SRC emacs-lisp
(setq projectile-switch-project-action 'helm-projectile)
#+END_SRC
**** File Management
- find file
- find file as root
- move / rename
- copy / delete
- search / replace
- misc.
  - insert as org link
  - ediff file
  - ediff merge file
  - etags
  - switch to eshell
  - eshell command on files
  - symlink files
  - relsymlink files
  - hardlink files
  - checksum file
  - print file
- Caching
#+BEGIN_SRC emacs-lisp
(setq projectile-enable-caching t)
#+END_SRC
**** virtual directory manager
- create dired buffer from files
- add files to a dired buffer
- remove entry(s) from Dired buffer
**** Buffer management
helm-projectile-switch-to-buffer C-c p b
**** Search in project
- helm-projectile-grep, C-c p s g
**** Summary of keybindings
| Key Binding | Command                                     | Description                                                         |
|-------------+---------------------------------------------+---------------------------------------------------------------------|
| C-c p h     | helm-projectile                             | Helm interface to projectile                                        |
| C-c p p     | helm-projectile-switch-project              | Switches to another projectile project                              |
| C-c p f     | helm-projectile-find-file                   | Lists all files in a project                                        |
| C-c p F     | helm-projectile-find-file-in-known-projects | Find file in all known projects                                     |
| C-c p g     | helm-projectile-find-file-dwim              | find file base on context at point                                  |
| C-c p d     | helm-projectile-find-dir                    | Lists available directories in current project                      |
| C-c p e     | helm-projectile-recentf                     | Lists recently opened files with same name but different extensions |
| C-c p a     | helm-projectile-find-other-file             | Switch between files with same name but different extensions        |
| C-c p i     | projectile-invalidate-cache                 | Invalidate cache                                                    |
| C-c p z     | projectile-cache-current-file               | add the file of current selected buffer to cache                    |
| C-c p b     | helm-projectile-switch-to-buffer            | List all open buffers in current project                            |
| C-c p s g   | helm-projectile-grep                        | Searches for symbol starting from project root                      |
| C-c p s a   | helm-projectile-ack                         | Searches as above but using ack                                     |
| C-c p s s   | helm-projectile-ag                          | Searches as above but using ag                                      |
|-------------+---------------------------------------------+---------------------------------------------------------------------|
*** Autoresize
#+BEGIN_SRC emacs-lisp
(helm-autoresize-mode t)
#+END_SRC
*** =helm-M-x=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-x") 'helm-M-x)
(setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
#+END_SRC
*** =helm-mini=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x b") 'helm-mini)
#+END_SRC
To enable fuzzy matching, add the following settings
#+BEGIN_SRC emacs-lisp
  (setq helm-buffers-fuzzy-matching t
        helm-recentf-fuzzy-match    t)
#+END_SRC
*** =helm-ff-do-grep=, live grep in Helm
#+BEGIN_SRC emacs-lisp
  (when (executable-find "ack-grep")
  (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
        helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))
#+END_SRC
*** =helm-semantic-or-imenu=
#+BEGIN_SRC emacs-lisp
(setq helm-semantic-fuzzy-match t
      helm-imenu-fuzzy-match    t)
#+END_SRC
*** =helm-man-woman=
_Key binding_:
<prefix> m
#+BEGIN_SRC emacs-lisp
(add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)
#+END_SRC
*** =helm-find=
_Key binding_:
<prefix> / (prefix is C-x c by default, or C-c h if set).
*** =helm-locate=
_Key binding_:
<prefix> l
#+BEGIN_SRC emacs-lisp
(setq helm-locate-fuzzy-match t)
#+END_SRC
*** =helm-occur=
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c h o") 'helm-occur)
#+END_SRC
*** =helm-descbinds=
#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
:ensure t
:config
(require 'helm-descbinds)
(helm-descbinds-mode))
#+END_SRC

* Files

** large-file-warning
#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold 100000000) ;; size in bytes
#+END_SRC
** Backup
#+BEGIN_SRC emacs-lisp
(defvar backup-directory "~/.backups")
(if (not (file-exists-p backup-directory))
    (make-directory backup-directory t))
(setq
 make-backup-files t        ; backup a file the first time it is saved
 backup-directory-alist `((".*" . ,backup-directory)) ; save backup files in ~/.backups
 backup-by-copying t     ; copy the current file into backup directory
 version-control t   ; version numbers for backup files
 delete-old-versions t   ; delete unnecessary versions
 kept-old-versions 6     ; oldest versions to keep when a new numbered backup is made (default: 2)
 kept-new-versions 9 ; newest versions to keep when a new numbered backup is made (default: 2)
 auto-save-default t ; auto-save every buffer that visits a file
 auto-save-timeout 20 ; number of seconds idle time before auto-save (default: 30)
 auto-save-interval 200 ; number of keystrokes between auto-saves (default: 300)
 )

#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
(setq
 dired-dwim-target t            ; if another Dired buffer is visible in another window, use that directory as target for Rename/Copy
 dired-recursive-copies 'always         ; "always" means no asking
 dired-recursive-deletes 'top           ; "top" means ask once for top level directory
 dired-listing-switches "-lha"          ; human-readable listing
 )
#+END_SRC
Automatically refresh dired buffer on changes
#+BEGIN_SRC emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC
If it is not windows, use the following listing switches
#+BEGIN_SRC emacs-lisp
;; if it is not Windows, use the following listing switches
(when (not (eq system-type 'windows-nt))
  (setq dired-listing-switches "-lha --group-directories-first"))
(require 'dired-x)
#+END_SRC
Wdired allows you to edit a Dired buffer and write changes to disk
#+BEGIN_SRC emacs-lisp
;; - Switch to Wdired by C-x C-q
;; - Edit the Dired buffer, i.e. change filenames
;; - Commit by C-c C-c, abort by C-c C-k
(require 'wdired)
(setq
 wdired-allow-to-change-permissions t   ; allow to edit permission bits
 wdired-allow-to-redirect-links t       ; allow to edit symlinks
 )
#+END_SRC
** Recentf
#+BEGIN_SRC emacs-lisp
(use-package recentf-mode
:ensure t
:config
(recentf-mode)
(setq
recentf-max-menu-items 30
recentf-max-saved-items 5000
))
#+END_SRC
** Dired+
_Author_:
_Homepage_:
_Features_:
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package dired+
:ensure t
:config
(require 'dired+))

#+END_SRC

_usage_:
** recentf-ext

_Author_:
_Homepage_:
_Features_:
Extension of `recentf` package.
- `dired` buffers can be handled
- switching to file buffer considers it as most recent file.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package recentf-ext
:ensure t
:config
(require 'recentf-ext))
#+END_SRC

_usage_:
** ztree
_Author_:
_Homepage_:
_Features_:
Ztree is a project dedicated to implementation of several text-tree applications inside Emacs. It consists of 2 sub-projects: ztree-diff and ztree-dir(the basis of ztree-diff).
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package ztree
:ensure t
:config
(require 'ztree-diff)
(require 'ztree-dir))
#+END_SRC
_usage_:
** vlf
_Author_:
_Homepage_:
_Features_:
Emacs minor mode that allows viewing, editing, searching and comparing large files in batches. Batch size can be adjusted on the fly and bounds the memory that is to be used for operations on the file. This way multiple large files (like terabytes or whatever) can be instantly and simultaneously accessed without swapping and degraded performance.

regular expression search on whole file (in constant memory determined by current batch size)
chunk editing (if size has changed, saving is done in constant memory determined by current batch size)
Occur like indexing
options to jump to beginning, end or arbitrary file chunk
ability to jump/insert given number of batches at once
newly added content is acknowledged if file has changed size meanwhile
automatic scrolling of batches
as a minor mode, font locking and functionality of the respective major mode is also present
by batch Ediff comparison
can be added as option to automatically open large files
smooth integration with hexl-mode
works with TRAMP so accessing network files is fine

_Installation_:
_usage_:

* Text
* Data
** saveplace
#+BEGIN_SRC emacs-lisp
;; saveplace remembers your location in a file when saving files
(require 'saveplace)
(setq-default save-place t)
#+END_SRC
** Password Management
#+BEGIN_SRC emacs-lisp
(use-package pass
:ensure t)

(use-package auth-password-store
  :ensure t
  :config
  (auth-pass-enable))
#+END_SRC

* External
** Processes
*** Flyspell
#+BEGIN_SRC emacs-lisp
(if (executable-find "aspell")
    (progn
      (setq ispell-program-name "aspell")
      (setq ispell-extra-args '("--sug-mode=ultra")))
  (setq ispell-program-name "ispell"))

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'org-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC
*** Gud
#+BEGIN_SRC emacs-lisp
(setq gud-chdir-before-run nil)
#+END_SRC
** term mode
#+BEGIN_SRC emacs-lisp
(defun my-term-setup ()
  (interactive)
  (define-key term-raw-map (kbd "C-y") 'term-send-raw)
  (define-key term-raw-map (kbd "C-p") 'term-send-raw)
  (define-key term-raw-map (kbd "C-n") 'term-send-raw)
  (define-key term-raw-map (kbd "C-s") 'term-send-raw)
  (define-key term-raw-map (kbd "C-r") 'term-send-raw)
  (define-key term-raw-map (kbd "M-w") 'kill-ring-save)
  (define-key term-raw-map (kbd "M-y") 'helm-show-kill-ring)
  (define-key term-raw-map (kbd "M-d") (lambda () (interactive) (term-send-raw-string "\ed")))
  (define-key term-raw-map (kbd "<C-backspace>") (lambda () (interactive) (term-send-raw-string "\e\C-?")))
  (define-key term-raw-map (kbd "M-p") (lambda () (interactive) (term-send-raw-string "\ep")))
  (define-key term-raw-map (kbd "M-n") (lambda () (interactive) (term-send-raw-string "\en")))
  (define-key term-raw-map (kbd "M-,") 'term-send-input)
  (define-key term-raw-map (kbd "C-c y") 'term-paste)
  (define-key term-raw-map (kbd "C-S-y") 'term-paste)
  (define-key term-raw-map (kbd "C-h") nil) ; unbind C-h
  (define-key term-raw-map (kbd "M-x") nil) ; unbind M-x
  (define-key term-raw-map (kbd "C-c C-b") 'helm-mini)
  (define-key term-raw-map (kbd "C-1") 'zygospore-toggle-delete-other-windows)
  (define-key term-raw-map (kbd "C-2") 'split-window-below)
  (define-key term-raw-map (kbd "C-3") 'split-window-right)
  (define-key term-mode-map (kbd "C-0") 'delete-window))
(add-hook 'term-mode-hook 'my-term-setup t)
(setq term-buffer-maximum-size 0)
(require 'term)
#+END_SRC
** ansi-term
#+BEGIN_SRC emacs-lisp
(defun visit-ansi-term ()
  "If the current buffer is:
     1) a running ansi-term named *ansi-term*, rename it.
     2) a stopped ansi-term, kill it and create a new one.
     3) a non ansi-term, go to an already running ansi-term
        or start a new one while killing a defunt one"
  (interactive)
  (let ((is-term (string= "term-mode" major-mode))
        (is-running (term-check-proc (buffer-name)))
        (term-cmd "/bin/zsh")
        (anon-term (get-buffer "*ansi-term*")))
    (if is-term
        (if is-running
            (if (string= "*ansi-term*" (buffer-name))
                ;; (call-interactively 'rename-buffer)
                (ansi-term term-cmd)
              (if anon-term
                  (switch-to-buffer "*ansi-term*")
                (ansi-term term-cmd)))
          (kill-buffer (buffer-name))
          (ansi-term term-cmd))
      (if anon-term
          (if (term-check-proc "*ansi-term*")
              (switch-to-buffer "*ansi-term*")
            (kill-buffer "*ansi-term*")
            (ansi-term term-cmd))
        (ansi-term term-cmd)))))

(global-set-key (kbd "<f2>") 'visit-ansi-term)
#+END_SRC
** shell-pop
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
:ensure t
:config
(require 'shell-pop)
(global-set-key (kbd "C-c t") 'shell-pop))
#+END_SRC
* Communication
This group allows to customize communications, networking and remote access to files. For example ftp, ldap, dig, whois, netstat.... I only enable =goto-address-mode= to enable URL highlighting and able to click it in any buffer.
** goto-address-mode
#+BEGIN_SRC emacs-lisp
;; go-to-address-mode
(add-hook 'prog-mode-hook 'goto-address-mode)
(add-hook 'text-mode-hook 'goto-address-mode)
#+END_SRC
* Programming
** Languages
*** C-C++
**** Development Environment Guide
***** Demo
- Switching between .h and .c/.cpp anywhere in the project like Linux
  Kernel. If more than one file exists, it displays a list of possible
  candidates. The command collects files of the same names but
  different across the project:
[[https://tuhdo.github.io/static/c-ide/projectile-find-other-file.gif]]
- Jump around Linux kernel source with ease using helm-gtags.
[[https://tuhdo.github.io/static/c-ide/helm-gtags-jump-dwim.gif]]
- Interactive outline tree using =moo-jump-local= from function-args
  package
[[https://tuhdo.github.io/static/c-ide/moo-jump-local.gif]]
- Static outline tree as a file browser
[[https://tuhdo.github.io/static/c-ide/sr-speedbar.gif]]
- Symbol references:
[[https://tuhdo.github.io/static/c-ide/semantic-symref.gif]]
- code completion
[[https://tuhdo.github.io/static/c-ide/semantic-boost-demo.gif]]
- code completion2
[[https://tuhdo.github.io/static/auto_complete.gif]]]]
- header completion
[[https://tuhdo.github.io/static/c-ide/company-c-header.png]]
- show function interface and variable definition at the bottom
[[https://tuhdo.github.io/static/func_args.jpg]]
[[https://tuhdo.github.io/static/c-ide/semantic-idle-summary-lambda.gif]]
[[https://tuhdo.github.io/static/c-ide/semantic-idle-summary-variable.gif]]
- show current function your cursor is inside at the top
[[https://tuhdo.github.io/static/c-ide/semantic-sticky-func.gif]]
- Compilation support
[[https://tuhdo.github.io/static/c-ide/compilation-mode.gif]]
- beautiful compile output
[[https://tuhdo.github.io/static/c-ide/compilation-compile.gif]]
- Fancy GDB debugging
[[https://tuhdo.github.io/static/c-ide/gdb-many-windows.gif]]
- Getting man pages for symbol at cursor
[[https://tuhdo.github.io/static/part3/helm-man-woman.gif]]

***** Basic Movement
- *C-M-f* runs =forward-sexp=, move forward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/forward-func.gif][file:static/c-ide/forward-func.gif]]

- *C-M-b* runs =backward-sexp=, move backward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/backward-func.gif][file:static/c-ide/backward-func.gif]]

- *C-M-k* runs =kill-sexp=, kill balanced expression
  forward that can be a pair or a symbol. Demo:

  [[file:static/c-ide/kill-func-body.gif][file:static/c-ide/kill-func-body.gif]]

- *C-M-<SPC>* or *C-M-@* runs =mark-sexp=, put mark after
  following expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/mark-func-body.gif][file:static/c-ide/mark-func-body.gif]]

- *C-M-a* runs =beginning-of-defun=, which moves point to beginning of
  a function. Demo:

  [[file:static/c-ide/beginning-of-defun.gif][file:static/c-ide/beginning-of-defun.gif]]

- *C-M-e* runs =end-of-defun=, which moves point to end of a
  function. Demo:

  [[file:static/c-ide/end-of-defun.gif][file:static/c-ide/end-of-defun.gif]]

- *C-M-h* runs =mark-defun=, which put a region around whole current
  or following function. Demo:

  [[file:static/c-ide/mark-defun.gif][file:static/c-ide/mark-defun.gif]]
***** Basic Concepts of Tag
A tag is a name of an entity in source code. An entity can be a variable, a method definition, an include-operator… A tag contains information such as name of the tag (the name of the variable, class, method), location of this tag in source code and which file it belongs to. As an example, GNU Global generates three tag databases:

+ GTAGS: definition database
+ GRTAGS: reference database
+ GPATH: path name database
A definition of a tag is where a tag is implemented. For example, a function definition is the body where it is actually implemented, or a variable definition is where the type and its property (i.e static) is specified.

A reference of a tag is where a tag is used in a source tree, but not where it is defined.

***** Browse source tree with =speedbar= file browser
=M-x speedbar=
_usage_:
- Use SPC to open the children of a node.
- RET to open the node in another window. If node is a file, open that file; if node is a directory, enter that directory; if node is a tag in a file, jump to the location of that tag in the file.
- U to go up parent directory.
- n or p moves to next or previous node.
- M-n or M-p moves to next or previous node at the current level.
- b switches to buffer list using Speedbar presentation. You can also open children of each buffer.
- f switches back to file list.

To enable =speedbar= to show all files:
#+BEGIN_SRC emacs-lisp
(setq speedbar-show-unknown-files t)
#+END_SRC
**** Company-c-headers
#+BEGIN_SRC emacs-lisp
(use-package company-c-headers
:ensure t
  :init
  (add-to-list 'company-backends 'company-c-headers))
#+END_SRC
**** hs-minor-mode for folding source code
#+BEGIN_SRC emacs-lisp
(add-hook 'c-mode-common-hook 'hs-minor-mode)
#+END_SRC
**** default-style
;; Available C style:
;; “gnu”: The default style for GNU projects
;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
;; “stroustrup”: What Stroustrup, the author of C++ used in his book
;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
;; “linux”: What the Linux developers use for kernel development
;; “python”: What Python developers use for extension modules
;; “java”: The default style for java-mode (see below)
;; “user”: When you want to define your own style
#+BEGIN_SRC emacs-lisp
(setq c-default-style "linux" ; set style to "linux"
      c-basic-offset 4)
#+END_SRC
**** cc-mode
#+BEGIN_SRC emacs-lisp
(use-package cc-mode
  :ensure t
  :config
  (define-key c-mode-map  [(tab)] 'company-complete)
  (define-key c++-mode-map  [(tab)] 'company-complete))
#+END_SRC
**** cedet
*What is CEDET?*
- (C)ollection of (E)macs (D)evelopment (E)nvironment (T)ools written with the end goal
of creating an advanced development environment in Emacs.

_Features_:
- intelligent completion
- source code navigation
- project management
- code generation with templates

*Why use CEDET?*
[[https://tuhdo.github.io/static/auto_complete.gif]]

#+BEGIN_SRC sh :noexports
#git clone  http://git.code.sf.net/p/cedet/git ~/.emacs.d/cedet
#cd ~/.emacs.d/cedet
#make
#cd contrib
#make
#+END_SRC
Need to learn :problem while installing
#+BEGIN_SRC emacs-lisp
;(load-file (concat "~/.emacs.d" "/cedet/cedet-devel-load.el"))
;(load-file (concat "~/.emacs.d" "cedet/contrib/cedet-contrib-load.el"))
#+END_SRC

*Semantic Minor Modes*


#+BEGIN_SRC emacs-lisp
(require 'cc-mode)
(require 'semantic)

(global-semanticdb-minor-mode 1)
(global-semantic-idle-scheduler-mode 1)
(global-semantic-stickyfunc-mode 1)

(semantic-mode 1)

(defun alexott/cedet-hook ()
  (local-set-key "\C-c\C-j" 'semantic-ia-fast-jump)
  (local-set-key "\C-c\C-s" 'semantic-ia-show-summary))

(add-hook 'c-mode-common-hook 'alexott/cedet-hook)
(add-hook 'c-mode-hook 'alexott/cedet-hook)
(add-hook 'c++-mode-hook 'alexott/cedet-hook)

;; Enable EDE only in C/C++
(require 'ede)
(global-ede-mode)

#+END_SRC
**** sr-speedbar
#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
:ensure t)
#+END_SRC
** Tools
*** GDB
#+BEGIN_SRC emacs-lisp
  (setq gdb-many-windows t
        gdb-show-main t)
#+END_SRC

*** Compilation
#+BEGIN_SRC emacs-lisp
  ;; Compilation from Emacs
  (defun prelude-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; we don't want to mess with child modes such as grep-mode, ack, ag, etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  ;; setup compilation-mode used by `compile' command
  (require 'compile)
  (setq compilation-ask-about-save nil ; just save before compiling
        compilation-always-kill t      ; just kill old compile process before starting the new one
        compilation-scroll-output 'first-error) ; automatically scroll to first
  (global-set-key (kbd "<f5>") 'compile)
#+END_SRC
*** Makefile
#+BEGIN_SRC emacs-lisp
;; takenn from prelude-c.el:48: https://github.com/bbatsov/prelude/blob/master/modules/prelude-c.el
(defun prelude-makefile-mode-defaults ()
  (whitespace-toggle-options '(tabs))
  (setq indent-tabs-mode t))

(setq prelude-makefile-mode-hook 'prelude-makefile-mode-defaults)

(add-hook 'makefile-mode-hook (lambda ()
                                (run-hooks 'prelude-makefile-mode-hook)))

#+END_SRC
*** Ediff
#+BEGIN_SRC emacs-lisp
(setq ediff-diff-options "-w"
      ediff-split-window-function 'split-window-horizontally
      ediff-window-setup-function 'ediff-setup-windows-plain)

#+END_SRC
*** diff-hl
_Author_:
_Homepage_:
_Features_:
=diff-hl-mode= highlights uncommitted changes on the left side of the window, allows you to jump between and revert them selectively.
[[https://tuhdo.github.io/static/part3/diff-hl-buffer.png]]
- =diff-hl-dired-mode= provides similar func in Dired.
[[https://tuhdo.github.io/static/part3/diff-hl-dired.png]]
- =diff-hl-margin-mode= changes the highlighting function to use the margin instead of the fringe
[[https://tuhdo.github.io/static/part3/diff-hl-margin.png]]
- =diff-hl-amend-mode= shifts the reference revision back by one
_Installation_:
#+BEGIN_SRC use-package
(use-package diff-hl
:ensure t
:config
(global-diff-hl-mode)
(add-hook 'dired-mode-hook 'diff-hl-dired-mode))
#+END_SRC
*** magit
_Author_:
_Homepage_:
_Features_:
Magit is an interface to the version control system Git, implemented as an Emacs extension.
_Installation_:
#+BEGIN_SRC emacs-lisp

    (use-package magit
    :ensure t
    :config
    (require 'magit)
    (set-default 'magit-stage-all-confirm nil)

   ;; full screen magit-status
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))

  (global-unset-key (kbd "C-x g"))
  (global-set-key (kbd "C-x g h") 'magit-log)
  (global-set-key (kbd "C-x g f") 'magit-file-log)
  (global-set-key (kbd "C-x g b") 'magit-blame-mode)
  (global-set-key (kbd "C-x g m") 'magit-branch-manager)
  (global-set-key (kbd "C-x g c") 'magit-branch)
  (global-set-key (kbd "C-x g s") 'magit-status)
  (global-set-key (kbd "C-x g r") 'magit-reflog)
  (global-set-key (kbd "C-x g t") 'magit-tag))
#+END_SRC
_Usage_:
Getting started with Magit is really easy:

- M-x magit-status to see git status, and in the status buffer:
- s to stage files
- c c to commit, type in your commit message then C-c C-c to save the message and commit, C-c C-k to abort current commit message and go back magit-status.
- b b to switch to a branch.

Other handy keys:

- P P to do a git push
- F F to do a git pull
- try to press TAB on entries.
If you want to view the raw git commands, i.e. you want to know how git push is doing, press $.

*** flycheck
_Author_:
_Homepage_:
_Features_:
- Supports over 30 programming and markup languages with more than 60 different syntax checking tools
- Fully automatic, fail-safe, on-the-fly syntax checking in background
- Nice error indication and highlighting
- Optional error list popup
- Many customization options
- A comprehensive manual
- A simple interface to define new syntax checkers
- A “doesn't get in your way” guarantee
- Many 3rd party extensions
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package flycheck
:ensure t
:config
(require 'flycheck)
(add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

*** flycheck-tip
_Author_:
_Homepage_:
_Features_: Show flycheck error by popup.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package flycheck-tip
:ensure t)
(require 'flycheck-tip)
;(flycheck-tip-use-timer 'verbose)
#+END_SRC
* Application
** Eshell
#+BEGIN_SRC emacs-lisp
(require 'eshell)
(require 'em-alias)
(require 'cl)

;; Advise find-file-other-window to accept more than one file
(defadvice find-file-other-window (around find-files activate)
  "Also find all files within a list of files. This even works recursively."
  (if (listp filename)
      (loop for f in filename do (find-file-other-window f wildcards))
    ad-do-it))

;; In Eshell, you can run the commands in M-x
;; Here are the aliases to the commands.
;; $* means accepts all arguments.
(eshell/alias "o" "")
(eshell/alias "o" "find-file-other-window $*")
(eshell/alias "vi" "find-file-other-window $*")
(eshell/alias "vim" "find-file-other-window $*")
(eshell/alias "emacs" "find-file-other-windpow $*")
(eshell/alias "em" "find-file-other-window $*")

(add-hook
 'eshell-mode-hook
 (lambda ()
   (setq pcomplete-cycle-completions nil)))

;; change listing switches based on OS
(when (not (eq system-type 'windows-nt))
  (eshell/alias "ls" "ls --color -h --group-directories-first $*"))
#+END_SRC
* Development
** Extensions
*** Eldoc
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
** Internal
Start Garbage Collection every 100MB to improve Emacs performance
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold 100000000)
#+END_SRC
* Environment
** initialization
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-screen t)
#+END_SRC
** Minibuffer
*** icomplete
#+BEGIN_SRC emacs-lisp
;(icomplete-mode)
#+END_SRC
*** Savehist
#+BEGIN_SRC emacs-lisp
;; savehist saves minibuffer history by defaults
(setq savehist-additional-variables '(search ring regexp-search-ring) ; also save your regexp search queries
      savehist-autosave-interval 60     ; save every minute
      )

#+END_SRC
** Windows
*** golden-ratio
_Author_:
_Homepage_:
_Features_:
_Automatic resizing of Emacs windows to the golden ratio
When working with many windows at the same time, each window has a size that is not convenient for editing.
[[https://tuhdo.github.io/static/part3/golden-ratio.gif]]
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
:ensure t
:config
(require 'golden-ratio)

(add-to-list 'golden-ratio-exclude-modes "ediff-mode")
(add-to-list 'golden-ratio-exclude-modes "helm-mode")
(add-to-list 'golden-ratio-exclude-modes "dired-mode")
(add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p)

(defun pl/helm-alive-p ()
  (if (boundp 'helm-alive-p)
      (symbol-value 'helm-alive-p)))

;; do not enable golden-raio in thses modes
(setq golden-ratio-exclude-modes '("ediff-mode"
                                   "gud-mode"
                                   "gdb-locals-mode"
                                   "gdb-registers-mode"
                                   "gdb-breakpoints-mode"
                                   "gdb-threads-mode"
                                   "gdb-frames-mode"
                                   "gdb-inferior-io-mode"
                                   "gud-mode"
                                   "gdb-inferior-io-mode"
                                   "gdb-disassembly-mode"
                                   "gdb-memory-mode"
                                   "magit-log-mode"
                                   "magit-reflog-mode"
                                   "magit-status-mode"
                                   "IELM"
                                   "eshell-mode" "dired-mode"))

(golden-ratio-mode))
#+END_SRC
_Usage_:
=C-x o= and see your windows being resized.

*** winner
#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC
** Mode Line
#+BEGIN_SRC emacs-lisp
(use-package mode-icons
  :ensure t
  :config
  (mode-icons-mode t)
)
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;  (use-package spaceline
;;    :ensure t
;;    :init
;;    (setq powerline-default-separator 'utf-8)
;;
;;    :config
;;    (require 'spaceline-config)
;;    (spaceline-spacemacs-theme)
;;    )
#+END_SRC
#+BEGIN_SRC emacs-lisp
 (use-package f
    :ensure t)

  (use-package projectile
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'projectile-mode))

(use-package powerline
    :ensure t
    :config
    (defvar mode-line-height 30 "A little bit taller, a little bit baller.")

    (defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#909fab" nil)))
    (defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
    (defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#9091AB" nil)))

    ;; Custom faces
    (defface mode-line-is-modified nil
      "Face for mode-line modified symbol")

    (defface mode-line-2 nil
      "The alternate color for mode-line text.")

    (defface mode-line-highlight nil
      "Face for bright segments of the mode-line.")

    (defface mode-line-count-face nil
      "Face for anzu/evil-substitute/evil-search number-of-matches display.")

    ;; Git/VCS segment faces
    (defface mode-line-vcs-info '((t (:inherit warning)))
      "")
    (defface mode-line-vcs-warning '((t (:inherit warning)))
      "")

    ;; Flycheck segment faces
    (defface doom-flycheck-error '((t (:inherit error)))
      "Face for flycheck error feedback in the modeline.")
    (defface doom-flycheck-warning '((t (:inherit warning)))
      "Face for flycheck warning feedback in the modeline.")


    (defun doom-ml-flycheck-count (state)
      "Return flycheck information for the given error type STATE."
      (when (flycheck-has-current-errors-p state)
        (if (eq 'running flycheck-last-status-change)
            "?"
          (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

    (defun doom-fix-unicode (font &rest chars)
      "Display certain unicode characters in a specific font.
  e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
      (declare (indent 1))
      (mapc (lambda (x) (set-fontset-font
                    t (cons x x)
                    (cond ((fontp font)
                           font)
                          ((listp font)
                           (font-spec :family (car font) :size (nth 1 font)))
                          ((stringp font)
                           (font-spec :family font))
                          (t (error "FONT is an invalid type: %s" font)))))
            chars))

    ;; Make certain unicode glyphs bigger for the mode-line.
    ;; FIXME Replace with all-the-icons?
    (doom-fix-unicode '("DejaVu Sans Mono" 15) ?✱) ;; modified symbol
    (let ((font "DejaVu Sans Mono for Powerline")) ;;
      (doom-fix-unicode (list font 12) ?)  ;; git symbol
      (doom-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
      (doom-fix-unicode (list font 15) ?)) ;; read-only symbol

    ;; So the mode-line can keep track of "the current window"
    (defvar mode-line-selected-window nil)
    (defun doom|set-selected-window (&rest _)
      (let ((window (frame-selected-window)))
        (when (and (windowp window)
                   (not (minibuffer-window-active-p window)))
          (setq mode-line-selected-window window))))
    (add-hook 'window-configuration-change-hook #'doom|set-selected-window)
    (add-hook 'focus-in-hook #'doom|set-selected-window)
    (advice-add 'select-window :after 'doom|set-selected-window)
    (advice-add 'select-frame  :after 'doom|set-selected-window)

    (defun doom/project-root (&optional strict-p)
      "Get the path to the root of your project."
      (let (projectile-require-project-root strict-p)
        (projectile-project-root)))

    (defun *buffer-path ()
      "Displays the buffer's full path relative to the project root (includes the
  project root). Excludes the file basename. See `*buffer-name' for that."
      (when buffer-file-name
        (propertize
         (f-dirname
          (let ((buffer-path (file-relative-name buffer-file-name (doom/project-root)))
                (max-length (truncate (/ (window-body-width) 1.75))))
            (concat (projectile-project-name) "/"
                    (if (> (length buffer-path) max-length)
                        (let ((path (reverse (split-string buffer-path "/" t)))
                              (output ""))
                          (when (and path (equal "" (car path)))
                            (setq path (cdr path)))
                          (while (and path (<= (length output) (- max-length 4)))
                            (setq output (concat (car path) "/" output))
                            (setq path (cdr path)))
                          (when path
                            (setq output (concat "../" output)))
                          (when (string-suffix-p "/" output)
                            (setq output (substring output 0 -1)))
                          output)
                      buffer-path))))
         'face (if active 'mode-line-2))))

    (defun *buffer-name ()
      "The buffer's base name or id."
      ;; FIXME Don't show uniquify tags
      (s-trim-left (format-mode-line "%b")))

    (defun *buffer-pwd ()
      "Displays `default-directory', for special buffers like the scratch buffer."
      (propertize
       (concat "[" (abbreviate-file-name default-directory) "]")
       'face 'mode-line-2))

    (defun *buffer-state ()
      "Displays symbols representing the buffer's state (non-existent/modified/read-only)"
      (when buffer-file-name
        (propertize
         (concat (if (not (file-exists-p buffer-file-name))
                     "∄"
                   (if (buffer-modified-p) "✱"))
                 (if buffer-read-only ""))
         'face 'mode-line-is-modified)))

    (defun *buffer-encoding-abbrev ()
      "The line ending convention used in the buffer."
      (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
          ""
        (symbol-name buffer-file-coding-system)))

    (defun *major-mode ()
      "The major mode, including process, environment and text-scale info."
      (concat (format-mode-line mode-name)
              (if (stringp mode-line-process) mode-line-process)
              (and (featurep 'face-remap)
                   (/= text-scale-mode-amount 0)
                   (format " (%+d)" text-scale-mode-amount))))

    (defun *vc ()
      "Displays the current branch, colored based on its state."
      (when vc-mode
        (let ((backend (concat " " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
              (face (let ((state (vc-state buffer-file-name)))
                      (cond ((memq state '(edited added))
                             'mode-line-vcs-info)
                            ((memq state '(removed needs-merge needs-update conflict removed unregistered))
                             'mode-line-vcs-warning)))))
          (if active
              (propertize backend 'face face)
            backend))))

    (defvar-local doom--flycheck-err-cache nil "")
    (defvar-local doom--flycheck-cache nil "")
    (defun *flycheck ()
      "Persistent and cached flycheck indicators in the mode-line."
      (when (and (featurep 'flycheck)
                 flycheck-mode
                 (or flycheck-current-errors
                     (eq 'running flycheck-last-status-change)))
        (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
                     (memq flycheck-last-status-change '(running not-checked)))
                 doom--flycheck-cache)
            (and (setq doom--flycheck-err-cache flycheck-current-errors)
                 (setq doom--flycheck-cache
                       (let ((fe (doom-ml-flycheck-count 'error))
                             (fw (doom-ml-flycheck-count 'warning)))
                         (concat
                          (if fe (propertize (format " •%d " fe)
                                             'face (if active
                                                       'doom-flycheck-error
                                                     'mode-line)))
                          (if fw (propertize (format " •%d " fw)
                                             'face (if active
                                                       'doom-flycheck-warning
                                                     'mode-line))))))))))

    (defun *buffer-position ()
      "A more vim-like buffer position."
      (let ((start (window-start))
            (end (window-end))
            (pend (point-max)))
        (if (and (= start 1)
                 (= end pend))
            ":All"
          (cond ((= start 1) ":Top")
                ((= end pend) ":Bot")
                (t (format ":%d%%%%" (/ end 0.01 pend)))))))

    (defun my-mode-line (&optional id)
      `(:eval
        (let* ((active (eq (selected-window) mode-line-selected-window))
               (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                          (*flycheck)
                          " "
                          (*buffer-path)
                          (*buffer-name)
                          " "
                          (*buffer-state)
                          ,(if (eq id 'scratch) '(*buffer-pwd))))
               (rhs (list (*buffer-encoding-abbrev) "  "
                          (*vc)
;;                          " "
;;                          (when persp-curr persp-modestring)
                          " " (*major-mode) "  "
                          (propertize
                           (concat "(%l,%c) " (*buffer-position))
                           'face (if active 'mode-line-2))))
               (middle (propertize
                        " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                           ,(1+ (string-width (format-mode-line rhs)))))))))
          (list lhs middle rhs))))

    (setq-default mode-line-format (my-mode-line)))

#+END_SRC
** Frames
*** Nyan
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
:ensure t
:config
(case window-system
  ((x w32) (nyan-mode)))
)
#+END_SRC
** scratch buffer
#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message "Alamin <3 Emacs")
#+END_SRC

** exec path
#+BEGIN_SRC emacs-lisp
(if (or
     (eq system-type 'darwin)
     (eq system-type 'berkeley-unix))
    (setq system-name (car (split-string system-name "\\."))))

(setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
(push "/usr/local/bin" exec-path)
#+END_SRC
** Keyboard
#+BEGIN_SRC emacs-lisp
(setq mac-option-modifier 'none)
(setq mac-command-modifier 'meta)
(setq ns-function-modifier 'hyper)
#+END_SRC
** Don't open files from the workspace in a new frame
#+BEGIN_SRC emacs-lisp
(setq ns-pop-up-frames nil)
#+END_SRC

** Theme and icons
*** arjen-grey-theme
#+BEGIN_SRC emacs-lisp
 (use-package arjen-grey-theme
   :ensure t
   :config
   (load-theme 'arjen-grey t))
#+END_SRC
*** base-16 theme
#+BEGIN_SRC emacs-lisp

 ;; (use-package base16-theme
 ;;   :ensure t
 ;;   :config
 ;;   (load-theme 'base16-materia))
#+END_SRC
*** all-the-icons
#+BEGIN_SRC emacs-lisp
;;   (use-package all-the-icons
;;     :ensure t)
#+END_SRC

* Faces
** Find out what face is used, so you can customize it :)
#+BEGIN_SRC emacs-lisp
;;; what-face to determine the face at the current point
(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property (point) 'read-face-name)
                  (get-char-property (point) 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Bars
#+BEGIN_SRC emacs-lisp
;; you won't need any of the bar thingies
;; turn it off to save screen estate
(if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC
** blink-cursor
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode -1)
#+END_SRC
** Size indication mode
#+BEGIN_SRC emacs-lisp
(size-indication-mode t)
#+END_SRC
** Mousewheel scrolling
#+BEGIN_SRC emacs-lisp
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+END_SRC

** More with Scroll
#+BEGIN_SRC emacs-lisp
(setq scroll-margin 0
      scroll-conservatively 100000
      scroll-preserve-screen-position 1)
#+END_SRC
** Frame Title
#+BEGIN_SRC emacs-lisp
;; more useful frame title, that show either a file or a
;; buffer name (if the buffer isn't visiting a file)
;; taken from prelude-ui.el
(setq frame-title-format
      '("" invocation-name " - " (:eval (if (buffer-file-name)
                                                    (abbreviate-file-name (buffer-file-name))
                                                  "%b"))))

#+END_SRC
** Default font
#+BEGIN_SRC emacs-lisp
(if (or (eq system-type 'darwin)(eq system-type 'gnu/linux) )
    (set-face-attribute 'default nil :font "Hack-16")
  (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 110))

;; set italic font for italic face, since Emacs does not set italic
;; face automatically
(set-face-attribute 'italic nil
                    :family "Hack-Italic")

#+END_SRC
** highlight-numbers
_Author_:
_Homepage_:
_Features_:
highlight-numbers is an Emacs minor mode that highlights numeric literals in source code.
_Installation_:
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
:ensure t
:config
(add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC
_Usage_:
Numbers automatically have distinct colors in buffer
** highlight-symbol:
_Author_:
_Homepage_:
_Features_:
Automatic and manual symbol highlighting for Emacs
_Installation_:
#+BEGIN_SRC emacs-lisp
  (use-package highlight-symbol
  :ensure t
  :config

  (require 'highlight-symbol)
  (highlight-symbol-nav-mode)
  (add-hook 'prog-mode-hook
            (lambda() (highlight-symbol-mode)))
  (add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))
(setq highlight-symbol-idle-delay 0.2
      highlight-symbol-on-navigation-p t)

(global-set-key [(control shift mouse-1)]
                (lambda (event)
                  (interactive "e")
                  (goto-char (posn-point (event-start event)))
                  (highlight-symbol-at-point)))

(global-set-key (kbd "M-n") 'highlight-symbol-next)
(global-set-key (kbd "M-p") 'highlight-symbol-prev))
#+END_SRC
_Usage_:
If you move point on a symbol, it automatically highlights all the symbols in the current screen. From now on, pressing M-n and M-p will immediately jump to the next/previous symbols in a buffer.
** disable beep
#+BEGIN_SRC emacs-lisp
;; http://stackoverflow.com/questions/11679700/emacs-disable-beep-when-trying-to-move-beyond-the-end-of-the-document
(defun my-bell-function ())

(setq ring-bell-function 'my-bell-function)
(setq visible-bell nil)
#+END_SRC

* Help
** info+
_author_:
_homepage_:
_Features_:
 Info+ helps you read Info documents more enjoyable with extra highlighting it provides.
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package info+
:ensure t
:config
(require 'info+))
#+END_SRC
** discover-my-major
_author_:
_homepage_:
_Features_:
Discover key bindings and their meaning for the current Emacs major mode.
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package discover-my-major
:ensure t
:config
;; A quick major mode help with discover-my-major
(global-unset-key (kbd "C-h h"))        ; original "C-h h" displays "hello world" in different languages
(define-key 'help-command (kbd "h m") 'discover-my-major)
)
#+END_SRC
_usage_:
The above setup binds C-h h m to discover-my-major. In a buffer, C-h h m and you will see key bindings of that major mode and its description, as opposed to usual C-h m which gives mappings between keys and commands.
** rainbow-mode
_author_:
_homepage_:
_Features_:
This minor mode sets background color to strings that match color names, e.g. #0000ff is displayed in white with a blue background.
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
:ensure t
:config
(add-hook 'html-mode-hook 'rainbow-mode)
(add-hook 'css-mode-hook 'rainbow-mode))
#+END_SRC
It is useful to always activate rainbow-mode in those two major modes. For other modes, it is situational, so I don't use prog-mode-hook.
_usage_:
As you type a hex number or a color string in a buffer with rainbow-mode activated, the hex number or color string is colorized.
** help+
_author_:
_homepage_:
_Features_:
Extension to help.el for emacs
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package help+
:ensure t
:config
(require 'help+))
#+END_SRC
_usage_:
The following bindings are made:

- `C-h u' `manual-entry'
- `C-h C-a' `apropos'
- `C-h C-l' `locate-library'
- `C-h RET' `help-on-click/key'
- `C-h M-a' `apropos-documentation'
- `C-h M-o' `pop-to-help-toggle'
- `C-h C-M-a' `tags-apropos'
- [mouse-1] `mouse-help-on-click' (non-mode-line)
- [mouse-1] `mouse-help-on-mode-line-click' (mode-line)

** help-fns+
_author_:
_homepage_:
_Features_:
Extension to help-fns.el for emacs
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package help-fns+
:ensure t
:config
(require 'help-fns+))
#+END_SRC
_usage_:

| Keys    | Bindings                                         |
| C-h B   | describe-buffer                                  |
| C-h c   | describe-command (replaces describe-key-briefly) |
| C-h o   | describe-option                                  |
| C-h C-c | describe-key-briefly (replaces C-h c)            |
| C-h C-o | describe-option-of-type                          |
| C-h M-c | describe-copying (replaces C-h C-c)              |
| C-h M-f | describe-file                                    |
| C-h M-k | describe-keymap                                  |
| C-h M-l | find-function-on-key                             |

** help-mode+
_author_:
_homepage_:
_Features_:
Extensions to `help-mode.el'

Links to libraries are provided whenever library names appear in buffer ‘*Help*’. After loading help-mode+.el, library names in buffer Help have mouse-over links to the corresponding library code.

For example, ‘C-h v features’ describes the variable ‘features’; this description lists all of the libraries currently loaded in Emacs.

- In vanilla Emacs (without help-mode+.el loaded), the library names are not linked, unless a library (such as ‘grep’) happens to have the same name as an Emacs function or variable, in which case clicking the name displays the function or variable description in buffer Help.
- With help-mode+.el loaded, each library name in the ‘C-h v features’ list is linked to the library (code) itself. Click a name to edit/view the library file.
_installation_:
#+BEGIN_SRC emacs-lisp
(use-package help-mode+
:ensure t
:config
(require 'help-mode+))
#+END_SRC
_usage_:
If a *Help* buffer contains other library names, the names automatically becomes links to jump to.

** which-key
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :config
  (which-key-mode))
#+END_SRC
** TODO Spell checking
#+BEGIN_SRC emacs-lisp
(defun spell-buffer-dutch ()
  (interactive)
  (ispell-change-dictionary "nl_NL")
  (flyspell-buffer))

(defun spell-buffer-english ()
  (interactive)
  (ispell-change-dictionary "en_US")
  (flyspell-buffer))

(use-package ispell
  :config
  (when (executable-find "hunspell")
    (setq-default ispell-program-name "hunspell")
    (setq ispell-really-hunspell t))

  ;; (setq ispell-program-name "aspell"
  ;;       ispell-extra-args '("--sug-mode=ultra"))
  :bind (("C-c N" . spell-buffer-dutch)
         ("C-c n" . spell-buffer-english)))

#+END_SRC
* Multimedia
* Local

* Writing
** Publishing
#+BEGIN_SRC emacs-lisp
(use-package request
:ensure t)
#+END_SRC

You will need an external library from Github Now for the leanpub-export
#+BEGIN_SRC emacs-lisp
;;(add-to-list 'load-path (expand-file-name (concat init-dir "ox-leanpub")))
;;(load-library "ox-leanpub")
(add-to-list 'load-path (expand-file-name (concat init-dir "ox-ghost")))
(load-library "ox-ghost")
;;; http://www.lakshminp.com/publishing-book-using-org-mode

;;(defun leanpub-export ()
;;  "Export buffer to a Leanpub book."
;;  (interactive)
;;  (if (file-exists-p "./Book.txt")
;;      (delete-file "./Book.txt"))
;;  (if (file-exists-p "./Sample.txt")
;;      (delete-file "./Sample.txt"))
;;  (org-map-entries
;;   (lambda ()
;;     (let* ((level (nth 1 (org-heading-components)))
;;            (tags (org-get-tags))
;;            (title (or (nth 4 (org-heading-components)) ""))
;;            (book-slug (org-entry-get (point) "TITLE"))
;;            (filename
;;             (or (org-entry-get (point) "EXPORT_FILE_NAME") (concat (replace-regexp-in-string " " "-" (downcase title)) ".md"))))
;;       (when (= level 1) ;; export only first level entries
;;         ;; add to Sample book if "sample" tag is found.
;;         (when (or (member "sample" tags)
;;                   ;;(string-prefix-p "frontmatter" filename) (string-prefix-p "mainmatter" filename)
;;                   )
;;           (append-to-file (concat filename "\n\n") nil "./Sample.txt"))
;;         (append-to-file (concat filename "\n\n") nil "./Book.txt")
;;         ;; set filename only if the property is missing
;;         (or (org-entry-get (point) "EXPORT_FILE_NAME")  (org-entry-put (point) "EXPORT_FILE_NAME" filename))
;;         (org-leanpub-export-to-markdown nil 1 nil)))) "-noexport")
;;  (org-save-all-org-buffers)
;;  nil
;;  nil)
;;
;;(require 'request)
;;
;;(defun leanpub-preview ()
;;  "Generate a preview of your book @ Leanpub."
;;  (interactive)
;;  (request
;;   "https://leanpub.com/clojure-on-the-server/preview.json" ;; or better yet, get the book slug from the buffer
;;   :type "POST"                                             ;; and construct the URL
;;   :data '(("api_key" . ""))
;;   :parser 'json-read
;;   :success (function*
;;             (lambda (&key data &allow-other-keys)
;;               (message "Preview generation queued at leanpub.com.")))))
#+END_SRC
** Word wrapping
please wrap text around when in text-modes. Also enable flyspell to catch nasty writing errors.
#+BEGIN_SRC emacs-lisp
  (dolist (hook '(text-mode-hook))
    (add-hook hook (lambda ()
                     (flyspell-mode 1)
                     (visual-line-mode  1))))
#+END_SRC
** Markdown support
Markdown is a great way to write documentation, not as good as org-mode of course, but generally accepted as a standard.
not as good as org-mode of course, but generally accepted as a standard.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
:ensure t)
#+END_SRC

** HTMLize buffers
#+BEGIN_SRC emacs-lisp
(use-package htmlize
:ensure t)
#+END_SRC

** Exports
Export ORG code fragments with a particular theme.

#+BEGIN_SRC emacs-lisp
(defun my/with-theme (theme fn &rest args)
  (let ((current-themes custom-enabled-themes))
    (mapcar #'disable-theme custom-enabled-themes)
    (load-theme theme t)
    (let ((result (apply fn args)))
      (mapcar #'disable-theme custom-enabled-themes)
      (mapcar (lambda (theme) (load-theme theme t)) current-themes)
      result)))
;;(advice-add #'org-export-to-file :around (apply-partially #'my/with-theme 'arjen-grey))
;;(advice-add #'org-export-to-buffer :around (apply-partially #'my/with-theme 'arjen-grey))
#+END_SRC
* TODO Org-Mode
#+BEGIN_SRC emacs-lisp
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
* TODO Email
