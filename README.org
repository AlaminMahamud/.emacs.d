#+TITLE: Alamin's Emacs Configuration
#+AUTHOR: Md. Alamin Mahamud
#+EMAIL: alamin.ineedahelp@gmail.com
#+STARTUP: overview indent inlineimages hideblocks
#+TAGS: Drill(d)
* Introduction
#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Alamin Mahamud")
  (setq user-mail-address "alamin.ineedahelp@gmail.com")
#+END_SRC

*** Credits
This Emacs Config has been created by shamelessly stealing other peoples config and docs.
Special thanks to Howard Abrams, Magnar Sveen, Tu do Hoang, John Weigley, Sacha Chua, Arjen Wiersma

*** Why Emacs?
Some Demo
- Performance: Editing a 39MB C source file with no problem. But well,
  it's not your favorite editor's fault if it crashes from editing
  such a large source file.

  [[https://tuhdo.github.io/static/performance.gif]]

- Programming:
  - Jump to any header file:

    [[https://tuhdo.github.io/static/jump_headers.gif]]

  - Autocompletion: Pay attention to completion candidates when
    ~include <linux/printk.h>~ is present and when it's not.

    [[https://tuhdo.github.io/static/auto_complete.gif]]

  - Showing function arguments:

    [[https://tuhdo.github.io/static/func_args.jpg]]

  - Quickly comment multiple lines:

    [[https://tuhdo.github.io/static/comment.gif]]

  - GDB:

    #+BEGIN_CENTER
    [[https://tuhdo.github.io/static/c-ide/gdb-many-windows.gif]]
    #+END_CENTER

- Diff between current editing file and latest file revision:

  [[https://tuhdo.github.io/static/vc-diff.jpg]]
  
- Magit: From unstage -> stage -> commit -> push

  [[https://tuhdo.github.io/static/magit.gif]]

- Live Grep:

  [[https://tuhdo.github.io/static/live_grep.gif]]

- Quickly select any file in a directory under a Version Control
  System, for example from the Linux kernel. Note that in the demos
  you may see me type in the commands. You can think of it like the
  start menu in Windows, but those commands can actually be executed
  quickly with a shortcut.

  [[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-1.gif]]

- Quickly select any file/directory from a previous working session:

  [[https://tuhdo.github.io/static/helm-buffer-list.gif]]

- Emacs is a PDF Reader: I can search text in the PDF file with
  highlighting and a table of contents side by side. All can be
  controlled with keyboard.

  [[https://tuhdo.github.io/static/emacs-read-pdf.gif]]

Finally, [[http://jtnimoy.net/workviewer.php?q%3D178][Emacs is featured in Tron Legacy]].

**** Other people's "Why Emacs?"
1. [[http://semantic.supelec.fr/popineau/programming-emacs.html#sec-1]["Why Emacs?"]] by Fabrice Popinea. He is the maintainer of Emacs 64 bit on Windows.
2. [[http://batsov.com/articles/2011/11/19/why-emacs/]["Why Emacs?"]] by Bozhidar Batsov. He is the author of [[https://github.com/bbatsov/prelude][Emacs Prelude]], an Emacs distribution with convenient packages for new people to get start with Emacs.
3. [[http://cs.mcgill.ca/~vfoley1/posts/2014-06-10-why-emacs.html][Why I use Emacs]] by Vincent Foley-Bourgon.
4. [[http://gnuvince.wordpress.com/2012/02/19/why-i-still-use-emacs/][Why I Still Use Emacs]], also by Vincent Foley-Bourgon.
5. [[http://emacs.sexy/][Emacs is sexy]].
*** A bit of history

Quotes from Emacs Homepage:

#+BEGIN_QUOTE
For those curious about Emacs history: Emacs was originally
implemented in 1976 on the MIT AI Lab's Incompatible Timesharing
System (ITS), as a collection of TECO macros. The name “Emacs” was
originally chosen as an abbreviation of “Editor MACroS”. This version
of Emacs, GNU Emacs, was originally written in 1984. For more
information, see the 1981 paper by Richard Stallman, describing the
design of the original Emacs and the lessons to be learned from it,
and a transcript of his 2002 speech at the International Lisp
Conference, My Lisp Experiences and the Development of GNU Emacs. Here
is the cover of the original Emacs Manual for ITS; the cover of the
original Emacs Manual for Twenex; and (the only cartoon RMS has ever
drawn) the Self-Documenting Extensible Editor.
#+END_QUOTE

**** More on Emacs history

Ever heard of a computing system called *Lisp Machine*? I bet many of
you don't. Me, too, until I started using Emacs and gradually learned
enough to know such a thing ever existed. This old article is an
interesting read: [[http://emacs.wordpress.com/2007/01/14/the-ghost-in-the-lisp-machine/][The Ghost in the Lisp Machine]]

#+BEGIN_QUOTE
A friend of mine used to say that Emacs fills our yearning for a Lisp
Machine. I tend to agree with him: Emacs is not just an editor, but a
full integrated environment where you can perform virtually any
imaginable task; and, most importantly, the inner workings of the
system are open to you to explore and extend. Using, for extra fun,
Lisp. No, i don’t think that Elisp is the nicest Lisp incarnation
around, but is far better than, say, C, and i still prefer it to other
scripting languages. Moreover, the awesome range of libraries at your
disposal makes up for many of the deficiencies in the language.

Living in Emacs is addictive. Imagine an operating system where you
can switch from writing code to browsing the web or chatting without
leaving a consistent environment, with the same set of commands and
shortcuts. Imagine a set of integrated applications where data is
seamlessly shared, where any single functionality can be tweaked,
extended and adapted to your particular needs. Where everything is
easily scriptable. Imagine, in addition, that the environment provides
powerful and complete interactive self-documentation facilities with
which the user can find out what is available. I have yet to find an
operating system providing such an integrated environment. Not even
Mac OS X, where AppleScript support is often lacking and system
services are underused.

Of course, the key ingredient here is Emacs’ extensibility. Far from
being an afterthought or simply one of its features, extensibility is
the central aspect of Emacs’ architecture. Actually, the whole point
of this post is to recommend you reading Richard Stallman’s 1981 essay
EMACS: The Extensible, Customizable Display Editor, which explains
much better than I could the strong points of Emacs design, i.e.,
those traits that make Emacs more, much more, than just an
editor. From the horse’s mouth:


    /Extensibility means that the user can add new editing commands or
    change old ones to fit his editing needs, while he is/
    /editing. EMACS is written in a modular fashion, composed of many
    separate and independent functions. The user extends EMACS by/
    /adding or replacing functions, writing their definitions in the
    same language that was used to write the original EMACS system. We/
    /will explain below why this is the only method of extension which
    is practical in use: others are theoretically equally good but/
    /discourage use, or discourage nontrivial use/.

    [...]

    /User customization helps in another, subtler way, by making the
    whole user community into a breeding and testing ground for new/
    /ideas. Users think of small changes, try them, and give them to
    other users–if an idea becomes popular, it can be incorporated/
    /into the core system. When we poll users on suggested changes,
    they can respond on the basis of actual experience rather than/
    /thought experiments./

The article goes on explaining the organization of the Emacs system,
how it depends on its interpreter, Elisp’s main features and how
built-in self-documentation is provided. Also interesting is the list
of related systems at the end of the essay: Lisp machines, LOGO,
MacLisp and Smalltalk. We’re definitely in good company!
#+END_QUOTE

Emacs is a miniature of a Lisp Machine. You can take a tour at the
[[http://www.sts.tu-harburg.de/~r.f.moeller/symbolics-info/symbolics.html][Lisp Machine online museum]].

*** "I don't want a complicated editor, I want something simple like Notepad"

Well, that's your choice. But I suggest that writing code without any
support is harmful.

A programmer should automate things as much as possible if the
automation cost does not outweigh the cost of doing it manually. One
/really easy/ way to do this is by using a good editor that automates
many menial and tedious tasks. For example, one of the things that
annoy me is using the command *cd* to change into a deep directory
path like this:

=/path/to/a/very/long/long/long/long/long/long/..../directory/=

In Emacs, if you have a directory under a version control system, you
can immediately jump to any file quickly, even if it is buried 20
levels deep (as demonstrated at the beginning).

Another example is quickly commenting out multiple lines of code in a
programming language that only supports single line comments. In many
editors you would have to tediously comment them out line by line. But
in Emacs you can simply highlight the lines and press a shortcut to
comment them out.

Many people think that writing programs manually makes them much
cooler than "amateurs" that use a fancy =Integrated Development
Environment=. I also used to think like that because working in a
Linux environment requires understanding of the underlying processes,
such as building software using a Makefile in C/C++, automating with a
shell script, installing software by compiling... And this is already
considered "user friendly" in the Linux world, as opposed to "click
the nice little play button" in a typical IDE. However, I was
wrong. While working with such tools allows me to understand what's
going on, I do not need to type in code manually to understand it. If
you get what a for loop does, typing it character by character is only
tedious and interrupts your thinking.

Writing code manually won't make you smarter, because you did the
thinking before you started to type. Typing is just a mere reflection
of your thoughts into the editor. You need to finish typing as fast as
possible, because the quicker you finish, the quicker you can get back
to your thinking. Only thoughts matter, and there's no value in
manually typing the same things thousands of times. I must say, =Cut=,
=Copy= and =Paste= are really great ideas and great automation tools
because of their simplicity.

If your job may require you to use an esoteric in-house programming
language and if you don't like it, having an editor to help you finish
the tasks as soon as possible is a way to make yourself happier.

Typing too much can also lead to RSI. Manually typing too much code is
harmful to your fingers. At least if you use a handsaw instead of a
circular saw, you do some physical exercise in the process.

In Sum:

- Manually typing does not make you smarter. Not in any form.
- Manually typing does not make you a better programmer.
- Manually typing or other tedious tasks (navigating the file system,
  remembering changes you made to your files...) are a waste of time if
  automating is possible. Automate as much as you can.
- Good editors help you automate boring tasks.
- Typing too much potentially leads to RSI.

Instead of wasting your time and memory on tedious tasks, you could
save it for more interesting things.
*** Installation
**** Linux:
:PROPERTIES:
:ID:       8acc1c68-72e7-4116-8afd-2265dda008d2
:END:
Easy way to install if you are using Ubuntu: =sudo apt-get install
emacs=. If you use other Linux distributions, use the package manager
of your distribution and install Emacs. However, the package manager
only has the latest stable Emacs; if you want the latest Emacs, build
it from source according to the instructions below.

To use Emacs with GUI:

- Install GTK 3: =sudo apt-get install libgtk-3-dev libgtk-3-common libgtk-3-0=
- Download [[http://www.gnu.org/software/emacs/][Emacs]]; or if you prefer the latest Emacs, get it from source: =git clone http://repo.or.cz/r/emacs.git=
- If you download from the homepage, unpackage: =tar xvf
  emacs-*.tar.gz=
- Install GTK: =sudo apt-get install libgtk-3-dev libgtk-3-common
  libgtk-3-0=. You have to use gtk3 to be able to use true type
  fonts.
- =cd emacs-<version>*=
- =./autogen.sh=
- Add prefix and path to where you want to install. This is useful if
  you work on a remote server without root access: =./configure
  --with-x-toolkit=gtk3 [--prefix=/path/to/dir]=

  You should use GTKx 3, so you will be able to use true type fonts
  such as Inconsolata for a better Emacs experience.
- =make=
- =sudo make install=

If =./configure= tells you there are dependencies missing, you should
install them. Recommended dependencies: libtiff, libgiff, libjpeg,
libpng and libxml2 for viewing and browsing web inside Emacs:

=sudo apt-get install libtiff5-dev libpng12-dev libjpeg-dev libgif-dev
libgnutls-dev libxml2-dev=

Using in Terminal only:

- Download and unpackage as above.
- =./configure --without-x [--prefix=/path/to/dir]=
- =make=
- =sudo make install=

If you don't like to compile Emacs yourself, install from the package
manager of your Linux distribution.

After installation is done, add this line to your *.bashrc* or *.zshrc*:

#+begin_src shell-script
  alias em='emacs'
#+end_src

So you can start Emacs as fast as vim!

**** Windows:
:PROPERTIES:
:ID:       301e3dcb-a00d-4b20-a5a8-f2b0946c56d1
:END:
You can either download it on GNU Emacs homepage or better, download
the latest 64 bit version:
http://semantic.supelec.fr/popineau/programming-emacs.html.

After that, unpackage it in =C:\Program Files\= and create a shortcut
to =C:\Program Files\Emacs\bin\emacsclientw.exe= on desktop.

**** Mac OS X:
:PROPERTIES:
:ID:       f86712b7-d138-4ad3-aef0-494a744c3b34
:END:
Download compiled Emacs for Mac OS X: http://emacsformacosx.com/.

You can also use this version that is more integrated with Mac OSX:
https://github.com/railwaycat/emacs-mac-port

*** Swap Control and Capslock

*Now I don't swap control and capslock.*

But those of who are interested can do this. by following these links.

Swapping Control and Capslock, in general, is not required to make the
best out of Emacs, if you at least use a regular key PC keyboard or
better. However, it is not nice at all on a laptop keyboard. If you
use a laptop keyboard for writing code, I strongly recommended to swap
Control and Capslock for a better Emacs experience.

Swapping Control and Caplock will not only benefit your Emacs usage,
it is beneficial in general, as Control is a much more frequently used
key than Capslock. Popular shells like Bash or Zsh use Control a lot
for quick cursor movement.

**** Windows
:PROPERTIES:
:ID:       eb9ffe1f-f726-4b15-8431-b075e9ba234d
:END:
   Follow this guide: [[http://www.kodiva.com/post/swapping-caps-lock-and-control-keys][Swapping Capslock and Control keys]]
**** Linux
:PROPERTIES:
:ID:       32a786e9-ae18-4c7b-9d12-1940e4f2d301
:END:
Put this in your shell init file (.bashrc, .zshrc...):

#+begin_src shell-script
  /usr/bin/setxkbmap -option "ctrl:swapcaps"
#+end_src

If you use Ubuntu, follow this guide: [[http://askubuntu.com/a/412622/13847][Swap caps lock and ctrl in
ubuntu 13.10]].
**** Mac OS X
:PROPERTIES:
:ID:       dc1f00fd-29a6-45e0-8398-211418cba728
:END:
Follow this answer on StackOverflow: [[http://stackoverflow.com/a/162907/496700][Emacs on Mac OS X Leopard key
bindings]]
**** If you don't like to swap Capslock and Control
You can use your palm to press Control in standard PC keyboard.
*** Concepts
**** Commands

In Emacs, every user interaction is a function execution. You press a
key to insert a character, Emacs runs =self-insert-command=. There are
two types of functions in Emacs:

    - *Normal functions*: These are like functions in other
      programming languages, and are used for implementing features in
      Emacs. Users do not need to care about these functions, unless
      they want to implement something or modify an existing
      implementation.

    - *Commands*: Commands are like functions, but interactive. It
      means, commands are features provided to users and users
      directly use them.

=execute-extended-command= is bound to *M-x*.
**** Emacs Key Notation
Taken from here: [[http://www.emacswiki.org/emacs/EmacsKeyNotation][EmacsWiki]]

| Prefix | Meaning                                                   |
|--------+-----------------------------------------------------------|
| =C-=     | (press and hold) the Control key                          |
|--------+-----------------------------------------------------------|
| =M-=     | the Meta key (the Alt key, on most keyboards)             |
|--------+-----------------------------------------------------------|
| =S-=     | the Shift key (e.g.‘S-TAB’ means Shift Tab)               |
|--------+-----------------------------------------------------------|
| =DEL=    | the Backspace key (not the Delete key). Inside Emacs, =DEL= |
|        | is written as =<backspace>=.                                |
|--------+-----------------------------------------------------------|
| =RET=    | the Return or Enter key                                   |
|--------+-----------------------------------------------------------|
| =SPC=    | the Space bar key                                         |
|--------+-----------------------------------------------------------|
| =ESC=    | the Escape key                                            |
|--------+-----------------------------------------------------------|
| =TAB=    | the TAB key                                               |
|--------+-----------------------------------------------------------|

A notation such as *C-M-x* (or, equivalently, *M-C-x*) means press and
hold both Control and Meta (Alt) keys while hitting the *x* key. From
now on, I won't say something like "Press *M-x*" anymore. For example,
if I say "*C-x C-f* your files", you should replace *C-x C-f* with its
command like this in your head: "=find-file= your files". All commands
use verbs, I think, so don't worry. Try to recall the command from the
key binding; it will help you get used to Emacs quicker. One exception
though: I only say "press *key*" if *key* is a single character on the
keyboard.

If you see =M-x command=, it means you need to *M-x* and type
*command*.

A prefix key is a part of a full key binding. For example, a full key
binding is *C-x r l* to run the command =bookmark-bmenu-list=, then
*C-x* and *C-x r* are its prefixes. Note that key sequence such as
*C-x* and *M-x* are considered a single character. Knowing prefix key
is handy: if you forget key bindings of some commands that use the
same prefix key, and remember the prefix, you can press the prefix key
and *C-h* to get a list of commands with that prefix.

For example, *C-x r* is the prefix for /register/ and /bookmark/
commands in Emacs. However, you forget a specific key binding for a
command in those features. *C-x r C-h* lists all key bindings that have
prefix *C-x r*.

Finally, *C-g* executes the command =keyboard-quit=, which cancels anything
Emacs is executing. If you press any key sequence wrongly, *C-g* to
cancel that incorrectly pressed key sequence and start again.

As you gradually learn Emacs, you will see the key bindings are really
systematically organized and mnemonic. Whenever you see key bindings
ending with *n* and *p*, it usually means *next* and *previous*; *o*
means *open*; *h* means *help*; *C-h* is standard prefix for help
commands; key bindings such as *o* and *C-o* are frequently used in
many built-in tools such as /Dired/, /Ibuffer/, /Occur/...
**** Ask for help - from Emacs
***** Built-in help system
:PROPERTIES:
:ID:       47d6ff15-1cf5-4a6a-a6b8-f4c83bac3927
:END:
I will describe some most useful commands based on my experience. I
will not list all, so you have to rely on Emacs to get your
information:

*C-h m* runs =describe-mode= to see all the key bindings
and documentation of current major mode and minor modes of a buffer.

*C-h w* runs =where-is= to get which keystrokes invoke a given command.

*C-h c* runs =describe-key-briefly= to find out what command is
bound to a key. For example, after *C-h c*, run *C-x C-f* gives
you *find-files*.

*C-h k* runs =describe-key= to find out what command is bound to a
key, along with the documentation of the command. Use this if you want
to know how to use a command.

*C-h e* runs =view-echo-area-messages=, allow you to see the
logging of echo area messages.

*C-h v* runs =describe-variable=, and asks you for a variable; you can
*TAB* to complete a variable. This command is important, because aside
from describing a variable, it allows you to customize the behavior
of Emacs and 3rd party packages. But for now, you don't need it.

*C-h C-h* runs *help-for-help*. Use this command if you want to see
a list of available help commands. Remember, if you partially remember a
key binding, just press as much as you can remember and then press
*C-h*, Emacs will list available commands for that prefix. Prefix *C-h*
is no exception. *C-h C-h* simply returns all key bindings and
commands of prefix *C-h*.

***** Info
:PROPERTIES:
:ID:       c40810fc-9af0-4b13-8fd2-db999d3e9859
:END:
=M-x info= or *C-h i* to see all the Info manual in Emacs. If you
want to learn more about Emacs, after reading my series of manuals,
the official Emacs manual in Info.

=M-x info-emacs-manual= or, *C-h r*, or *<f1> r* to see manual section
for Emacs.

Use Info often whenever you need to learn something in Emacs. Use it
early to create a good habit of reading documentation, and this is
beneficial not only for Emacs.

***** Man
:PROPERTIES:
:ID:       6edee0b5-213a-4fd4-9c40-041206b86a52
:END:
You can view man pages with two commands:

- =M-x man=: Get a UNIX manual page and put it in a buffer.
- =M-x woman=: Browse UN*X man page for TOPIC (Without using external
  Man program). It means, you can view man page without having the
  =man= program installed, while the =man= command above invokes
  external =man= program.

**** Point
Point is your current cursor position. From now on, instead of saying
"current cursor", I say "point".
**** Opening files
:PROPERTIES:
:ID:       cdb163ad-eb98-46af-83b5-d9ad1803a0d1
:END:
Let's learn one especially handy command. =M-x find-=, then press
*TAB*. You will see Emacs offers you a list of possible commands with
prefix =find-=. Select the command =find-file=, either by clicking on
it in the list; or keep typing a few more characters, and pressing
*TAB* until the command is completed. After =find-file= is in your
prompt, press *RET*. For quickly running =find-file=, you can use key
binding *C-x C-f*.

You can use *wildcard expression* to select more than one file. For
example, if your directory contains these file:

- =file_a_1.c=
- =file_a_2.c=
- =file_a_3.c=
- =file_b_1.c=
- =file_b_1.h=
- =file_b_2.c=

Then in *find-file* prompt, you can open all file with extension =.c=
like this: =file*.c=. Or if you only want to select file with character
=a= in it: =*a*.c=. Or if you only want to select file with =1= and
extension =.c.= in it: =*1.c=. Basically, wildcard expression =*=
accepts anything.

During the exercise, if something happens, for example, you press the
wrong keys and Emacs is behaving weird, just press *C-g*.

The command you have just executed is for browsing and opening files
in Emacs, similar to =Open With= in regular editors, except that
instead of navigating with the mouse, you navigate with keyboard,
which is much faster.

If you use =find-file= to navigate to an existing file in a deep
directory and press *RET*, it opens that file. Otherwise, if the file
does not exist and you press *RET*, you create a new file. Woot, two
features in a single command, so convenient. If you intend to open a
file at first, but then realize that you want to create a file
there, =Open With= doesn't allow you to do that. You have to navigate
all the way back with typical *New File* feature in regular editors.

Another interesting command in Emacs is =find-file-at-point=.
What this function does is that if you have a path to a directory or
file under point,  =M-x ffap= opens that directory or file directly!

[[https://tuhdo.github.io/static/ffap.gif]]

As you see in the demo, if for some reason, the directory at
point does not exist, =ffap= tries the parent directory until one
exist. In the example, only =/home/= exists and got fed into the
prompt.
**** Ido mode
:PROPERTIES:
:ID:       a1982da3-6c2d-4d8b-bdaf-ab4d9d37e1a7
:END:
Emacs has an interesting feature called *Ido*, short for
*Interactively Do Things*. In essence, *Ido* is a superior interface
to interactively select things in Emacs compared to a plain prompt.

To activate *Ido*, =M-x ido-mode=. Let's open a file with *C-x
C-f*. Do you find this:

[[https://tuhdo.github.io/static/find-file-normal.gif]]

Or this:

[[https://tuhdo.github.io/static/find-file-ido.gif]]

Which is better?

Once enabled, Ido is used for most commands that require you to select
something from a list.

A few things to note for when using *Ido*:

- If you want to use wildcard expression, you have to temporary revert
  to ordinary =find-file= via *C-f*.

- If you want to select the current directory, *C-d*. This invokes
  *Dired* file manager to open the directory and list the files in
  current directory. You will learn Dired in later section. For now,
  if you open the directory, close the current listing by *C-x k* and
  press *RET*.

- You select a directory in =find-file= prompt by pressing *RET*, not
  *TAB* like ordinary =find-file=.

Regardless, an alternative interface for completion and narrowing
exists, arguably more powerful, but you have to install a 3rd party
package. The package is called Helm. However, let's stick with *Ido*
through the rest of this manual.

**** Buffer
Buffer is where you edit your file content. Buffer holds content
of a file temporarily. Anything you write into the buffer won't make
it into file until you explicitly save it with =save-buffer=
command. *C-x C-s* executes the command =save-buffer=, so you can *C-x
C-s* your files. You can also execute this from =M-x*=

To save a buffer as other file ("Save As" in other editors), *C-x
C-w*, which runs the commands =write-file=.

To kill a buffer, *C-x k*. If you want to kill the current buffer,
*RET* immediately. Otherwise, type into the prompt the buffer name you
want to kill.

In the previous section I said that point is in your file, well,
actually point is not in a file but in a buffer. From now on, keep
file and buffer two separate and distinct concepts. When I say file, I
refer to physical file and when I say buffer, I refer to the temporary
content of the file that is being displayed.

*_Exercise_*: Practice *C-x b* to get used to it.


| Key       | Binding                             |
|-----------+-------------------------------------|
| =C-x C-s= | *Command*: =save-buffer=            |
|           | Save the buffer at point            |
|-----------+-------------------------------------|
| =C-x C-w= | *Command*: =write-file=             |
|           | Save the buffer to a different file |
|-----------+-------------------------------------|
| =C-x b=   | *Command*: =switch-to-buffer=       |
|           | Switch to a different buffer        |
|-----------+-------------------------------------|
| =C-x k=   | *Command*: =kill-buffer=            |
|           | Kill a buffer. *RET* to kill the    |
|           | currently  active one               |
|-----------+-------------------------------------|

**** Major mode
:PROPERTIES:
:ID:       2d67567c-985d-49af-83d1-f36ebda0e20c
:END:
Major modes provide specialized facilities for working on a particular
file type, such as syntax highlighting for a programming language.
Major modes are mutually exclusive; each buffer has one and only one
major mode at any time.

Emacs is bundled with many major modes for editing source code in
different languages: C, C++, Java, Lisp, bash, asm... For example,
when opening a file with =.c= extension, Emacs automatically
recognizes it's a C file and selects the C major mode to highlight the
buffer properly.

**** Minor mode
:PROPERTIES:
:ID:       9e9200cb-9205-4931-8795-b9c9e00f95f2
:END:
Minor modes are optional features which you can turn on or off, not
necessarily specific to a type of file or buffer. For example, Auto
Fill mode is a minor mode in which *SPC* breaks lines between words
as you type. Minor modes are independent of one another, and of the
selected major mode.

**** Basic buffer managements
:PROPERTIES:
:ID:       520961cd-e999-4730-a208-dfa8db1c5fa3
:END:
So, you learn how to open file and create buffer of that file.
In other editors, you got something called "tabs". Every time you open a
file, you get a file tab for selecting an "opening file" (which is called
buffer in Emacs). It quickly becomes a nuisance once you have lots of
file tabs. If you use multi-row support for file tabs, it eats up your
editing space.

How do you switch between opening buffers? *C-x b* opens a prompt to
enter a buffer name. You can *TAB* to complete the buffer name similar
to how you complete file names in *C-x C-f*.

After you open a file, and if point is in that buffer, *C-x C-f*
prompts the current directory, so you can open another file within
this directory. For example, buffer A is from =~/dir1/= and buffer B
is in =~/dir2/=, if point is in buffer A, *C-x C-f* starts in
=~/dir1/=; if point is in buffer B, *C-x C-f* starts in =~/dir2/=.

In an Emacs session, you may have a lot of buffers, including
non-file buffers such as shell buffers, email buffers... How do you
manage buffers when it's getting large? *C-x C-b* executes
=list-buffers=, provide you a list of buffer in which you can
search. However, =list-buffers= is a simple command for buffer
management. Emacs also provides =ibuffer=, which is a superior
alternative. You will surely want to use =ibuffer=, but first let's
replace =list-buffers= with =ibuffer= (by placing next directive to your =~/.emacs= file):

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+end_src

Remember to save into =*scratch*= buffer and then =M-x eval-buffer=
for the setup to take effect.

Let's play with *ibuffer*.

*_Exercise_*:

- First, open many files with different extensions. The Emacs source
  you used for installation is an great practice target. If you use a
  built binary, [[http://ftp.gnu.org/gnu/emacs/emacs-24.3.tar.gz][download it]] and unpackage. Let's assume you download
  and unpackage it at =~/Downloads/emacs-24.3=.

- *C-x C-f*, navigate to =emacs-24.3/lisp/= and open all Lisp files:
  =*.el=. If you use *Ido*, remember to *C-f* before type into the prompt

- *C-x C-f*, navigate to =emacs-24.3/src/= and open all C files:
  =*.c=.

- Open *ibuffer* by *C-x C-b*. You see a huge list of buffers.

Now the fun begins.

- Suppose that you want to work with C code. */ m* and enter a major
  mode to select buffers that belong to this major mode. Prefix */* in
  *ibuffer* groups filtering commands. *TAB* to see a list of major
  modes:

  [[https://tuhdo.github.io/static/ibuffer-filter-major.gif]]

- Enter =c-mode=.

- Only C buffers remain. But you open buffers in two major modes:
  =c-mode= and =emacs-lisp-mode=. You can create each group for one by
  pressing */ g*, and give the group a name. Only execute */ g* after
  executing any filtering commands.

- Up to this point, the filtering is still applied. Press */ /* to
  remove previous filter and return the full buffer list.

- Let's create another group based filtering. */ m* and enter
  =emacs-lisp-mode=. Create another group with */ g* and give it a
  name. Now, every time you open files that their buffers satisfy the
  filtering criteria, the buffers are put into appropriate groups.

- To open a buffer, *o* or *C-o*. *o* opens a buffer and switch point
  to it. *C-o* leaves point on the buffer list. Let's open a buffer
  with *o* and *C-o*. To switch back to the other buffer, do *C-x
  o*. *C-x o* executes =other-window= command, which cycles among the
  opening buffers (technically the buffers are in Emacs "windows",
  and you are cycling "windows", but we will get to that later).

- Either using *C-o* or *o* creates another buffer below, leaving
  you two horizontal buffers. You probably don't like the layout because you
  have a big screen. If you use *o*, *C-x o* to switch back to the
  list and *C-x 1* to close other buffer. If you have multiple buffers
  opened, *C-x 1* closes all others and leave the active buffer (the
  one with point, which is our buffer list) remains. To close an
  active buffer, *C-x 0*. *C-x 3* to create a vertical buffer to the
  right. It creates an exact duplicate of the active buffer. Now, *o*
  on any C buffer again, and point is in that buffer:

  [[https://tuhdo.github.io/static/c-x-3.gif]]

- Edit something in the buffer. Switch back to =ibuffer= and press
  *g*, which runs the command =ibuffer-update= to refresh the
  list. You will see an asterisk on the left of your just edited
  buffer. It indicates that buffer has been modified.

- You can also mark a buffer by pressing *m* on multiple entries to
  perform various operations:

  - *view*: press *A* to view the marked buffers

  - *save*: press *S* to save the marked buffers

  - *close*: press *D* to close the marked buffers

  - *revert*: press *V* to discard changes to the marked buffers

  To unmark a buffer, press *u* on the marked entries.

- Another way to open the buffer: *e* (/enter/), *f* (/find/) or *RET*
  to bury and replace the list with selected buffer. Switch back to
  the list using *C-x C-b* again.

To sum up, I will list the key bindings your used in this section
along with other useful key bindings:

- *C-x C-b* to open =ibuffer=.
- *o* or *C-o* to open a buffer at point.
- *e*, *f* or *RET* bury the buffer list and replace it with the
  buffer content.
- *=* to compare the current buffer content with its file.

*Tip*: When point is on an entry, *C-x C-f* starts at the current
directory of buffer of that entry.

- Filtering commands:

| Key   | Bindings                        |
|-------+---------------------------------|
| =/ m= | Add a filter by a major mode    |
|-------+---------------------------------|
| =/ n= | Add a filter by buffer name.    |
|-------+---------------------------------|
| =/ c= | Add a filter by buffer content. |
|-------+---------------------------------|
| =/ f= | Add a filter by filename        |
|-------+---------------------------------|
| =/ >= | Add a filter by buffer size     |
|-------+---------------------------------|
| =/ <= | Add a filter by buffer size     |
|-------+---------------------------------|
| =/ /= | Remove all filters in effect    |
|-------+---------------------------------|

- Filter group commands:

| Key   | Bindings                                    |
|-------+-------------------------------------|
| =/ g= | Create a filter group from filters  |
|-------+-------------------------------------|
| =TAB= | Move to next filter group           |
|-------+-------------------------------------|
| =M-p= | Move to previous filter group       |
|-------+-------------------------------------|
| =/ \= | Remove all active filter groups     |
|-------+-------------------------------------|
| =/ S= | Save the current groups with a name |
|-------+-------------------------------------|
| =/ R= | Restore previously saved groups     |
|-------+-------------------------------------|
| =/ X= | Delete previously saved groups      |
|-------+-------------------------------------|

- Sorting commands:

| Key   | Bindings                          |
|-------+-----------------------------------|
| =,=   | Rotate between sorting modes      |
|-------+-----------------------------------|
| =s i= | Reverse current sorting order     |
|-------+-----------------------------------|
| =s a= | Sort buffers by alphabet          |
|-------+-----------------------------------|
| =s f= | Sort buffers by filename          |
|-------+-----------------------------------|
| =s v= | Sort buffers by last viewing time |
|-------+-----------------------------------|
| =s s= | Sort buffers by size              |
|-------+-----------------------------------|
| =s m= | Sort buffers by major modes       |
|-------+-----------------------------------|

To quit =ibuffer=, press *q*.

**** Bookmark: save locations across Emacs sessions
:PROPERTIES:
:ID:       801bd37d-dd77-4d3d-9925-4980cabaefd7
:END:
When you read books, you usually cannot read all at once and place a
bookmark to go back to continue reading later. Emacs allows you to
bookmark too.

| Key       | Binding                                                                       |
|-----------+-------------------------------------------------------------------------------|
| =C-x r m= | *Command*: =bookmark-set=                                                     |
|           | Set bookmark at point. After executing the command, a prompt asks for a name. |
|           | Enter the name and *RET*.                                                     |
|-----------+-------------------------------------------------------------------------------|
| =C-x r b= | *Command*: =bookmark-jump=                                                    |
|           | Jump to a saved bookmark, specified by user. *TAB* for getting bookmark list. |
|           |                                                                               |
|-----------+-------------------------------------------------------------------------------|
| =C-x r l= | *Command*: =bookmark-bmenu-list=                                              |
|           | Open the list of all bookmarks.                                               |
|-----------+-------------------------------------------------------------------------------|

Remember that key bindings are easy. You just need to remember that *C-x
r* is the prefix for bookmark related commands. *m* stands for *mark*,
meaning you *mark* something in some place; *b* stands for bookmark,
meaning you can switch to any bookmark quickly, similar to *C-x b*
switches to buffers quickly. Finally, *l* means *list* for listing
bookmarks, analogous to =ibuffer= for listing buffers. If you want to
preserve the bookmarks across Emacs sessions, *C-x r l* to open the
bookmark list and press *s* to save the list to file.

If you understand how to manage buffers, managing bookmarks is the
same, with different but similar key bindings. Finally, you cannot
only bookmark buffers that are associated with files, you can bookmark
non-file buffers too:

- =Dired= buffers
- Info buffers
- Man pages

A few useful key bindings when in =bookmark-bmenu-list=:

| Key   | Binding                                                         |
|-------+-----------------------------------------------------------------|
| =RET= | Open a bookmark.                                                |
|       | After you opened the bookmark, you can go back to bookmark list |
|       | by *C-x r l*.                                                   |
|-------+-----------------------------------------------------------------|
| =1=   | Open a bookmark and close other buffers                         |
|-------+-----------------------------------------------------------------|
| =n=   | Go to next entry                                                |
|-------+-----------------------------------------------------------------|
| =p=   | Go to previous entry                                            |
|-------+-----------------------------------------------------------------|
| =s=   | Save the current bookmark list to file.                         |
|-------+-----------------------------------------------------------------|
| =o=   | Open bookmark in other window and move point to it. If you      |
|       | want to view side by side, *C-x 3* to create a vertical buffer  |
|       | and bookmark will be opened in the vertical buffer.             |
|-------+-----------------------------------------------------------------|
| =C-o= | Similar to =o= but point remains on the bookmark list.          |
|-------+-----------------------------------------------------------------|
| =r=   | Rename bookmark at point.                                       |
|-------+-----------------------------------------------------------------|
| =m=   | Mark bookmark at point for displaying.                          |
|-------+-----------------------------------------------------------------|
| =v=   | Display all marked bookmarks.                                   |
|-------+-----------------------------------------------------------------|
| =d=   | Flag bookmark for deletion.                                     |
|-------+-----------------------------------------------------------------|
| =x=   | Delete flagged bookmarks.                                       |
|-------+-----------------------------------------------------------------|
| =u=   | Unmark marked or flagged bookmarks.                             |
|-------+-----------------------------------------------------------------|

*_Exercise_*:

- Open files and create a few bookmarks. *C-x r b* to switch between
  them.
- *C-h i* to open Info. Pick a node and enter as deep as you
  want. Then bookmark and kill current Info buffer.
- *C-x r l* to open the bookmark list and practice the key bindings in the table.

**** Basic motion commands
:PROPERTIES:
:ID:       C405EA55-1F5B-4828-A83D-4EC96C5B6AD1
:END:
These key bindings are also used by popular shells such as *bash* or
*zsh*. I highly recommended you to master these key bindings.

- Move forward one char: *C-f* (f stands for *forward*)
- Move backward one char: *C-b* (b stands for *backward*)
- Move upward one line: *C-p* (p stands for *previous*)
- Move downward one line: *C-n* (n stands for *next*)

The above operations can also be done with arrow keys. If you don't
like the above key bindings, the arrow keys offer equivalent features.

- Move to beginning of line: *C-a*
- Move to end of line: *C-e*
- Move forward one word, *M-f*.
- Move backward one word, *M-b*.

These key bindings are in Emacs only:

- Scroll forward one screen: *C-v*, *page down*
- Scroll backward one screen: *M-v*, *page up*
- Move to the beginning of a sentence: *M-a*
- Move to the end of a sentence: *M-e*
- Recenter a screen: *C-l*
- Re-position point to the top, middle and bottom of the current
  screen: *M-r*
- Move to top of the buffer: *M-<*
- Move to end of the buffer: *M->*
- Move to the nth character: *M-g c* (c stands for =character=)
- Move to the nth line: *M-g l* for Emacs < 23.2, *M-g g* for emacs >=
  23.2) (l/g stands for =line=)

Recenter means making the current line point the center of your
screen.

*_Exercise_*: execute the above commands using the key bindings at
least 10 times or until you remember. You can perform these motion
commands on any buffer.
**** Useful built-in key bindings for navigating pairs
:PROPERTIES:
:ID:       7522b365-52f4-4fa9-b316-7843b772c59a
:END:

- *C-M-f* binds to =forward-sexp=, move forward over a balanced
  expression. Demo:

  [[https://tuhdo.github.io/static/part3/forward-sexp.gif]]

- *C-M-b* binds to =backward-sexp=, move backward over a balanced
  expression. Demo:

  [[https://tuhdo.github.io/static/part3/backward-sexp.gif]]

- *C-M-k* binds to =kill-sexp=, kill balanced expression
  forward. Demo:

  [[https://tuhdo.github.io/static/part3/kill-sexp.gif]]

- *C-M-t* binds to =transpose-sexps=, transpose expressions. Demo:

  [[https://tuhdo.github.io/static/part3/transpose-sexp.gif]]

- *C-M-<SPC>* or *C-M-@* binds to =mark-sexp=, put mark after
  following expression. Demo:

  [[https://tuhdo.github.io/static/part3/mark-sexp.gif]]

**** Basic editing commands
:PROPERTIES:
:ID:       11496600-7D09-468D-A6BC-C6113ACCCAC7
:END:
In Emacs, =kill= means =Cut= in other editors. These key bindings also
work under the terminal.

- Kill a character at the point: *C-d*
- Kill entire line: *C-S-DEL* (remember, *DEL* is your *<backspace>* key)
- Kill forward to the end of a word from current point: *M-d*
- Kill backward to the beginning of a word from the current point:
  *M-DEL*
- Kill all spaces at point: *M-\*
- Kill all spaces except one at point: *M-SPC*
- Kill to the end of line: *C-k*
- Kill a sentence: *M-k*

When you kill something, the killed content is put into the Kill Ring.

If you write code, you can also quickly add comments or
comment/uncomment code with *M-;*:

- If you do not highlight a text region, *M-;* adds a comment to the
  end of line.
- If you highlight a region (i.e. with a mouse), *M-;* comments out
  the region.

**** Dynamic Abbreviations
:PROPERTIES:
:ID:       8232e425-1aec-4a4a-85de-900faa19a8b1
:END:
Dynamic Abbreviations are a completion feature in Emacs, but work for
text and is context-independent. After you type a word once, if you
type that word again, you can type it partially and *M-/* to complete
it. If you type a prefix that has many candidates, *M-/* cycles the
candidates. This is a really cool feature and you ought to try it.

*_Exercise_*:

- Type "thisIsaVeryVeryVeryVeryLongWord" into a buffer of your choice.
- Add newline or whitespace.
- Type "thisIs" and *M-/*. Great, Emacs automatically completes for you.
- Type "random" into your buffer and *M-/*. You will see Emacs
  tell your that no dynamic abbreviations found.
- Type "randomWord" and add a whitespace. Now, type "random" and *M-/*
  again. Emacs can now happily complete "random" for you. Remember that
  to let Emacs remember your words, you have to type a complete word.
**** Kill ring
:PROPERTIES:
:ID:       7F7CD162-4C59-43D8-B445-ECB28D042CC0
:END:

Kill ring is the list of previously killed contents. You can insert the
most recently killed element by *C-y*.

If you supply a number, using *C-<number>* - *<number>* can be any
number - before you *C-y*, to paste the nth entry in the kill
ring. The most recent entry is 1st entry. *C-1 C-y* is the same as
*C-y*; *C-2 C-y* is the 2nd most recent entry, make that entry the
head of the list and so on...

Let's play with the kill ring for a while. Open a buffer and insert
these 3 lines:

#+BEGIN_HTML
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aaa <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bbb <br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ccc
#+END_HTML

Then:

- Kill the three lines with *C-k*, from top to bottom.

- *C-y* or *C-1 C-y*, you will see =ccc= got inserted.

- *C-2 C-y*, you will see =bbb= got inserted; *C-y* again, you will
  see =bbb= got inserted again. =bbb= now becomes head of the list.

- *C-2 C-y*, you will see =aaa= got inserted; *C-y* again, you will
  see =aaa= got inserted again. =aaa= now bedcomes head of the list.

- Insert the 3 lines and kill all again.

- *C-3 C-y*, you will see =aaa= got inserted; *C-y* again, you will
  see =aaa= got inserted again. =aaa= now bedcomes head of the list

- ... and so on ...

*C-<number>* is called prefix argument. Basically it's for altering
the behavior of you command. You will learn about prefix
argument in later section.

Alternatively to the above sequence, you can use *M-y* which runs
=yank-pop=. By default, when *C-y*, it inserts the most recent killed
text. If you want to retrieve earlier kill texts, after *C-y*, *M-y*
to cycle through the entries in =kill-ring=. You must first run *C-y*,
otherwise *M-y* has no effect.

You may wonder, what happens if the kill ring getting really large,
how can you remember where is which? That's right. It's a problem, and
that's when the 3rd party plugins shine. However, you can view the
kill ring with *C-h v*, then enter =kill-ring=. After this, you will
see the =kill-ring= content, but in its code form, which is not really
pretty and friendly.

**** Mark and region
:PROPERTIES:
:ID:       01EA0EFF-2A5F-4E68-8A29-A9DB8A0DB2EA
:END:
Mark is a record of a position in a buffer. It's like when reading a
book, you record various places in a book and these records are called
bookmarks. It is similar, except it is buffer mark in Emacs (Emacs also
has bookmark, but we will discuss later).

When you set mark between two points in a buffer, the text between two
points are highlighted. We call the highlighted text a region.
When the region is highlighted, we say the region is active;
to deactivate a region, press *C-g* or move point around, just
like in other text editors.

*_Exercise_*:

+ Place a mark in buffer with *C-SPC C-SPC*. Let's call this mark *A*.

+ Move to another place in the buffer, place another mark with *C-SPC
  C-SPC*. this is mark *B*.

+ Move to another place and *C-SPC C-SPC* again. This is mark *C*.

+ Now press *C-u C-SPC*. You can see point goes back to mark
  *B*.

+ *C-u C-SPC* again. Point goes back to mark *A*.

+ *C-u C-SPC* again. Point goes back to mark *C*.

+ Let's create a region: *C-SPC*, then move point forward. What
  happened?

+ The highlighted area is called a region. You can perform editing
  commands on the region:
  - *C-w* to kill the region
  - *M-w* to copy the region
  - *C-y* to yank (equivalent to paste) the region.

+ Let's copy or kill a region; you should select a big region. Now
  yank (paste) it elsewhere. After yanking, you notice point is
  not at the original location anymore. If you want to return to the
  where you yanked, *C-u C-SPC* or *C-x C-x*.

  When you yank, you create a mark at point before the new content is
  inserted. After the content is inserted, point moves according to
  the size of the content. In general, most Emacs commands that create
  sudden displacement push marks, so you can go back to previous
  locations without having to tediously scroll the whole buffer.

  *C-x C-x* executes the command =exchange-point-and-mark=, which
  exchanges the point and the mark created when you yank with
  *C-y*. Try and see. When this command is executed, region bounded by
  the mark and point is activated.  Using *C-x C-x* is really
  convenient. Instead of highlighting line by line for =Copy= or
  =Kill=, you can do this:

  [[https://tuhdo.github.io/static/c-x-c-x.gif]]

  Remember when you have to highlight a big region and for some
  reason, you lose the highlighting and have to do it all over
  again. *C-x C-x* saves you from that tedium.

  *C-u C-SPC* simply returns you to previous mark location inserted
  when you *C-y*. This command won't activate region.

  Practice until you get used to these two commands.
**** Mark ring
:PROPERTIES:
:ID:       025E9CF4-B70C-41FA-A51D-AE3E2391227D
:END:
Emacs stores buffer marks in a list, that's why you are able to cycle
through various marks in the exercise above. You can cycle through the
list to jump to a mark, or with extension packages, you can have a
list and interactively select it. *Helm* is an excellent example of
such an extension. We will discuss more on extension packages later.

**** Global mark ring
:PROPERTIES:
:ID:       4B4B71A3-80F4-4716-80FB-FA0270B88357
:END:
Mark ring is local to each buffer. If you switch to another buffer,
you have a new local mark ring.

Global mark ring is like mark ring, but they persist across
buffers. Each time you set a mark, that mark is set in global mark
ring in addition to the buffer's mark ring.

You cycle the global mark ring by *C-x C-SPC*.

**** Undo/redo
:PROPERTIES:
:ID:       709F26BC-3A20-47C1-93C6-264C00CD5C89
:END:
To undo: *C-/* or *C-x u*

To redo, it's quite tricky to do because you have to understand how
undo in emacs works. When you edit, emacs tracks changes in your
current editing file. For example, you insert the following line in
your file:

 #+BEGIN_HTML
 aaa <br />
 bbb <br />
 ccc
 #+END_HTML

Then, Emacs tracks the history like this:

- insert: "aaa"
- insert: "bbb"
- insert: "ccc"

Now, execute undo twice. Your file becomes:

aaa

The history of the file changes:

- insert: "aaa"
- insert: "bbb"
- insert: "ccc"
- undo insert: "ccc"
- undo insert: "bbb"

How do insert back *bbb* and *ccc*. By undo your previous undos! ook
closely at the above change history again. You see that Emacs keeps
track your recent undo actions. execute some motion command, i.e
*C-f*, then try *C-/* twice and see what happens.

Great, you get your old content, *bbb* and *ccc* back. That is because
you have just undone the latest "undo insert: ..." entries in the file
history.

When you was execute a series of undoing, /without any other commands in
between/, Emacs keeps reverting to the older content. The series of
*undo insert: ...* got inserted into your file history when you break the
undo series with other commands.

Again, two features in one command, but a bit confusing this time.

*_Exercise_*: Practice undoing/redoing until you get used to.
**** Search for text
:PROPERTIES:
:ID:       ca3e54c5-fbc6-457f-b82e-55fe59cc3ef9
:END:
Content search is an essential feature in every editor. Emacs has many
built-in tools for this problem.
**** Incremental search
:PROPERTIES:
:ID:       84B3D9CC-C246-4D3C-9022-49CB47813094
:END:
So, you want to look for something in the buffer? *C-s* invokes
=isearch-forward=, allows you to look forward from the current point
for something. After *C-s*, you are prompted to enter the content to
search for. Enter the content, and press *C-s* repeatedly to travel
through the matches forward.

Similarly, *C-r* invokes =isearch-backward=, allows you to look
backward from the current point. Press *C-r* repeatedly to travel
through the matches backward.

=isearch= can be invoked from any valid buffer. You can perform
=isearch= on =ibuffer=.

*_Exercise_*:

Open a reasonably large text file of your choice for practicing.

*C-s*, then type the search content and repeatedly press *C-s*. After
repeated a few times, press *C-r* repeatedly. What happened?

You can invoke *C-r* within *C-s* and vice verse to go to the next and
previous match.

*C-g* to cancels the current search session.

Move point to a word. *C-s* then *C-w*, selects content from point to
end of a word. For example, if point is on character 'e' of "Hello
world" *C-w* feeds "ello" into current *C-s* prompt.

*C-w* again feeds " world" into current prompt to become "ello world"
and so on.

*C-g*, then *C-s* again. You can select the old input to search again with:

- *M-p* moves to the previous input.
- *M-n* moves to the next input.

If you want to search with regexp, *C-u C-s*.

Now you get the basics of Isearch, it has more useful commands that
are bound to *M-s* prefix key:

| Key       | Binding                                      |
|-----------+----------------------------------------------|
| =M-s .=   | *Command*: =isearch-forward-symbol-at-point= |
|           | Feed the symbol at point to *C-s*            |
|           | perform search                               |
|-----------+----------------------------------------------|
| =M-s o=   | *Command*: =occur=                           |
|           | Run =occur=                                  |
|-----------+----------------------------------------------|
| =M-s h .= | *Command*: =highlight-symbol-at-point=       |
|           | Highlight the symbol at point                |
|-----------+----------------------------------------------|
| =M-s h l= | *Command*: =highlight-lines-matching-regexp= |
|           | Highlight lines that match input regexp      |
|-----------+----------------------------------------------|
| =M-s h r= | *Command*: =highlight-regexp=                |
|           | Highlight according to regexp                |
|-----------+----------------------------------------------|
| =M-s h u= | *Command*: =unhighlight-regexp=              |
|           | Turn off highlighting strings that match     |
|           | regexp.                                      |
|-----------+----------------------------------------------|

**** Occur
:PROPERTIES:
:ID:       e49a59d6-efab-401c-9164-0ae45806e719
:END:
Command =occur= lists all line that match a string or a regexp and
displays the search result in a buffer named =*Occur*=. =occur= is
useful in situation where you have a large number of matches and need
a better tool to manage rather than going back and forth with
Isearch. For example, you have a match around line 1000, but you are
currently at line 500. In between the two lines are many other
matches. You cannot use Isearch to jump through them all. This is
where =*Occur*= is handy. =*Occur*= is also useful for query and
replace a string with another, and allow you to verify that you did
indeed replace the correct string.

To invoke =occur=, run =M-s o=; if you =M-s o= in Isearch prompt,
=occur= will get the text currently using. Quite convenient. You can
use *M-g n* and *M-g p* to go to next/previous matches, or use the
mouse to scroll. If you feel *M-g p* and *M-g n* to go back and forth
is annoying, you can repeat it using *C-x z* which runs =repeat=:

- *M-g n* to go to next match.
- *C-x z* to repeat previous command.
- From now on, keep pressing *z* to repeat previous command until your
  press a different character.

Demo, notice how the inactive cursor at the =*Occur*= buffer moves as point in
my main buffer moves:

[[https://tuhdo.github.io/static/occur.gif]]

You can operate directly on occur buffer. In =*Occur*= buffer, use
*C-p* and *C-n* to go to previous and next entries. Press *o* jumps to
the match at point and switch point to buffer that contains the
match; *C-o* to open the match at point but not switching buffer. If
you want to edit the matches, press *e* to enter =occur-edit-mode=;
after that, you can edit anywhere in the =*Occur*= buffer and see your
changes updated as you type on the other buffer. You can do any
editing commands when in =occur-edit-mode=, such as commands for query
replace in previous section to replace all matches.

Demo:

[[https://tuhdo.github.io/static/occur-edit.gif]]

Here are key bindings in =occur=:

| Key       | Binding                             |
|-----------+-------------------------------------|
| =C-n=     | Go to next line                     |
|-----------+-------------------------------------|
| =C-p=     | Go to previous line                 |
|-----------+-------------------------------------|
| =<=       | Go to beginning of buffer           |
|-----------+-------------------------------------|
| =>=       | Go to end of buffer                 |
|-----------+-------------------------------------|
| =e=       | Edit current =*Occur*= buffer       |
|-----------+-------------------------------------|
| =C-c C-c= | When finish with editing, =C-c C-c= |
|           | to exit editing mode                |
|-----------+-------------------------------------|
| =g=       | If your searching file is updated,  |
|           | press =g= refreshes the =*Occur*=   |
|           | buffer to reflect the changes       |
|-----------+-------------------------------------|
| =o=       | Jump to the match and switch point  |
|-----------+-------------------------------------|
| =C-o=     | Jump to the match but point remain  |
|           | on =*Occur*=                        |
|-----------+-------------------------------------|

If you want to have this table (and more key bindings), in =*Occur*=
buffer runs *C-h m* or press *h*. Finally, press *q* to quit =*Occur*=
buffer.

**** Query replace
:PROPERTIES:
:ID:       4145517f-b864-47f3-bc8b-63509a59d26c
:END:
To replace something, *M-%* to execute *query-replace*. *M-%* asks you
two inputs:

- A string to be replaced.
- A string to replace.

Supply the inputs and *RET*.

Emacs will ask your confirmation to replace a matched string. If you
want to replace all, press *!* instead of answer yes or no (*Note:* it
will replace ocurrences only *beneath* your current point).

If you want to query and replace with regexp, *C-M-%*. *Tip*: this
command is a bit hard to press; to make it easy, use both of your
hands:

- It can be that left hand presses *%* (or *S-5*) and right hand presses
  *C-M-*.
- It can be that right hand presses *C-* first, then left hand presses
  *M-%*.

**** Multi-occur
:PROPERTIES:
:ID:       49674610-411e-4345-a954-f333bced3969
:END:
It is the same as =occur= except it asks user for multiple buffers.

- =multi-occur= asks for buffers to search. You enter buffer by buffer
  until you give it empty input.
- =multi-occur-in-matching-buffers= requires a regexp, and it searches
  for occurences in buffers that match the regexp.

**** Grep
:PROPERTIES:
:ID:       9e55a123-c29d-4b48-bc2c-4e2d0ab191c5
:END:
=M-x rgrep= allows you to search for text with external =grep= command
and displays the results in a buffer. The good thing about running
=grep= in Emacs is that the raw output are processed. The end results
are colored and clickable, so that you can quickly visit the matched
location!

=rgrep= recursively greps for =regexp= in =files= in directory tree rooted
at =dir=. You will be prompted for these three inputs when =rgrep= runs.

With *C-u* prefix, you can edit the constructed shell command line
before it is executed. With two *C-u* prefixes, directly edit and run
=grep-find-command= (this is a variable), which is the underlying
command used for executing =rgrep=.

[[https://tuhdo.github.io/static/grep.gif]]

When you get a list of results displayed in a buffer named =*grep*=,
you can click on the results or use *M-g p* and *M-g n* to back and
forth between grep results, even if point is not active in =*grep*=
buffer.

The following key bindings are available:

| Key     | Description                                                           |
|---------+-----------------------------------------------------------------------|
| *TAB*   | Go to next match, but *do not* display matched buffer                 |
|---------+-----------------------------------------------------------------------|
| *S-TAB* | Go to previous match, but *do not* display matched buffer             |
|---------+-----------------------------------------------------------------------|
| *{*     | Go to previous file, *do not* display matched buffer                  |
|---------+-----------------------------------------------------------------------|
| *}*     | Go to next file, *do not* display matched buffer                      |
|---------+-----------------------------------------------------------------------|
| *C-o*   | Display matched location, but *do not* switch point to matched buffer |
|         | (Only available in Emacs > 24.3)                                              |
|---------+-----------------------------------------------------------------------|
| *n*     | Display next matched buffer, but *do not* switch point                |
|---------+-----------------------------------------------------------------------|
| *p*     | Display previous matched buffer, but *do not* switch point            |
|---------+-----------------------------------------------------------------------|
| *M-g n* | Display next matched buffer, switch point to matched position         |
|---------+-----------------------------------------------------------------------|
| *M-g p* | Display previous matched buffer, switch point to matched position     |
|---------+-----------------------------------------------------------------------|
| *RET*   | Display matched location, switch point to matched bufer               |
|---------+-----------------------------------------------------------------------|
| *SPC*   | Scroll down, equivalent to *C-v*                                      |
|---------+-----------------------------------------------------------------------|
| *S-SPC* | Scroll up, equivalent to *M-v*                                        |
|---------+-----------------------------------------------------------------------|
| *g*     | Refresh the =*grep*= buffer with previously executed command          |
|---------+-----------------------------------------------------------------------|
| *q*     | Quit =*grep*= buffer                                                  |
|---------+-----------------------------------------------------------------------|

To get the list of key bindings, in =*grep*= buffer, type =?= or =h=
or *C-h m*. Such a big list of key bindings, but worry not. These key
bindings are quite common in other Emacs utilities. You can reuse many
of these key bindings.

**** Modeline
:PROPERTIES:
:ID:       d0ff17f7-bb7f-4923-b4d9-ddbf7b8a143b
:END:
The mode line is the empty area below the buffer. It has useful
summary information about the buffer shown in the window.

The text displayed in the mode line has the following format:

#+BEGIN_CENTER
~cs:ch-fr     |  buf |  pos line | (major minor)~

For example, a modeline looks like this:
#+END_CENTER


[[https://tuhdo.github.io/static/modeline.jpg]]

=cs= describes the character set of the text in the buffer. Do you see
the character =U= in the picture? It means your text is represented by
UTF-8 coding system.

If you type text in different human languages, and if the input method is
on, to the left of the =U= appears the symbol of that language,
i.e. =\U=, the backslash means =TeX input method=. *C-\* prompts you
to select a language. After selecting, subsequent *C-\* toggles the
selected input method on and off. You can set the input method again
with =M-x set-input-method=.

=ch= describes editing state of current buffer:

- This shows two dashes (‘--’) if the buffer displayed in the window
  has the same contents as the corresponding file on the disk; i.e.,
  if the buffer is “unmodified”.
- If the buffer is modified, it shows two stars (‘**’). For a
  read-only buffer, it shows ‘%*’ if the buffer is modified, and ‘%%’
  otherwise. You can see that in the picture, the buffer is modified.

=fr= gives the selected frame name. A frame is a Emacs window in your
OS. For example, these are two Emacs frames:

[[https://tuhdo.github.io/static/frames-gui.gif]]

If you are using the GUI version of Emacs, it will always be a
dash. However, if you use Emacs in terminal, you cannot have multiple
frame window like the above screenshot. Instead, Emacs creates
/virtual frames/ with names like F1, F2..., Fn like this (notice my
mouse pointer):

[[https://tuhdo.github.io/static/frames-term.gif]]

=buf= is buffer name. Buffer name is usually file name; but they can
have different names.

=pos= is display the current position of your viewing screen. If your
viewing screen starts from the first line, it displays as =Top=. If
you viewing screen contains the last line of your buffer, it displays
as =Bottom=. Otherwise, it displays *%* position, i.e. 20% means you
viewing screen is 20% away from the top.

=line= displays the current line number.

=major= displays the current major mode.

=minor= displays the current minor mode.

**** Minibuffer
:PROPERTIES:
:ID:       c20af14e-8eca-4698-b4b0-d95ded1724ee
:END:
=Minibuffer= is the small area at the bottom of your Emacs screen.

The =Minibuffer= is where Emacs commands read complicated arguments,
such as file names, buffer names, Emacs command names, or Lisp
expressions. When you execute =find-file=, it asks for your file from the
=Minibuffer=, which is one of =find-file= required argument. Remember I
said earlier that in Emacs, everything is a function. =find-file= is a
command, in other words, it's an interactive function. As a function,
it also takes arguments. =Minibuffer= is where users can feed arguments
to the interactive functions.

Minibuffer has an input history. If you enter anything into the
minibuffer and *RET*, minibuffer remembers the input and you can access
the input again with:

- *M-p* moves to the previous input in minibuffer history.
- *M-n* moves to the next input in minibuffer history.
- *M-r* searches for an input that matches the supplied regexp.

It works on any command that get input from the minibuffer, as you
already used *M-p* and *M-n* to get old inputs in Isearch.

**** Echo area
:PROPERTIES:
:ID:       e5ca41b8-5058-4f98-8b21-c906bc80a4d7
:END:
=Minibuffer= can be used for output as well. The echo area is used for
displaying messages made with the message primitive, and for echoing
keystrokes.

Both =Minibuffer= and =Echo Area=, although serve different purposes,
share the same physical space. You should not be confused between the two.

**** Frames
:PROPERTIES:
:ID:       9d06632d-a923-47ee-8ca2-e2b4a106dad3
:END:

An application window in an operating system is called a *Frame* in
Emacs. So, you execute *Emacs* from the command line and open Emacs,
that's a frame that contains your Emacs session. Emacs can have
multiple frames to hold different parts of Emacs, such as a separate
frame to hold the minibuffer.

Personally, I only use a single frame. However, frames can be useful
if you want to organize buffers into different groups.  For example,
each frame can be a project: frame F1 holds buffers related to my C
programming projects, frame F2 holds buffers related to customizing
Emacs, frame F3 holds buffers related to emails and reading,
newsgroups...

As stated earlier, multiple frames under the terminal have names
F1, F2 .... Fn for each frame.

These are the key bindings for manipulating frames:

| Key         | Binding                                               |
|-------------+-------------------------------------------------------|
| =C-x 5 C-f= | *Command*: =find-file-other-frame=                    |
|             | Open file in a different frame                        |
|-------------+-------------------------------------------------------|
| =C-x 5 f=   | *Command*: =find-file-other-frame=                    |
|             | Same as *C-x 5 C-f*                                   |
|-------------+-------------------------------------------------------|
| =C-x 5 C-o= | *Command*: =display-buffer-other-frame=               |
|             | Open buffer in a different frame and move point there |
|-------------+-------------------------------------------------------|
| =C-x 5 .=   | *Command*: =find-tag-other-frame=                     |
|             | Find tag at point in a different frame                |
|-------------+-------------------------------------------------------|
| =C-x 5 0=   | *Command*: =delete-frame=                             |
|             | Delete the current frame point is in                  |
|-------------+-------------------------------------------------------|
| =C-x 5 1=   | *Command*: =delete-other-frames=                      |
|             | Delete other frames except the one at point       |
|-------------+-------------------------------------------------------|
| =C-x 5 2=   | *Command*: =make-frame-command=                       |
|             | Create a frame                                        |
|-------------+-------------------------------------------------------|
| =C-x 5 b=   | *Command*: =switch-to-buffer-other-frame=             |
|             | Same as *C-x 5 C-o*                                   |
|-------------+-------------------------------------------------------|
| =C-x 5 d=   | *Command*: =dired-other-frame=                        |
|             | Open a Dired buffer in another frame                  |
|-------------+-------------------------------------------------------|
| =C-x 5 m=   | *Command*: =compose-mail-other-frame=                 |
|             | Open another frame for composing email                |
|-------------+-------------------------------------------------------|
| =C-x 5 o=   | *Command*: =other-frame=                              |
|             | Cycle through available frames                        |
|-------------+-------------------------------------------------------|
| =C-x 5 r=   | *Command*: =find-file-read-only-other-frame=          |
|             | Open file for read only in another frame              |
|-------------+-------------------------------------------------------|

**** Window
:PROPERTIES:
:ID:       f988d119-d683-4568-8b38-cb3b700b7abf
:END:
Unlike other editors, Emacs can split your frame area into multiple smaller
areas. Each such area is called a =window=. You can divide a frame
into as many windows as you want and each window can have anything in
it, i.e. your current editing buffer, file management buffer, help
buffer, a shell... Basically anything that Emacs can display. Let's try them out:

*_Exercise_*:

*C-x 2* to split the current window into two horizontal windows. After
splitting, you will have the exact duplicate of your current editing
buffer. =split-window-below= is bound to *C-x 2*.

*C-x 3* to split your current window into two vertical windows. After
splitting, you will have the exact duplicate of your current editing
buffer. =split-window-right= is bound to *C-x 3*.

Now, after you execute the two commands above, you will have three
windows: two above and one below. Each window can hold a buffer. With
the above two commands, you can create arbitrary window layout. In
Emacs, a window layout is called a *window configuration*.

To navigate through the windows, use *C-x o* which runs the command
=other-window=. Try cycle around the windows a few times to get used
to it.

In Emacs, =<next>= is the *PageDown* key, =<prior>= is the *PageUp*
key. *M-<next>* runs =scroll-other-window= and scroll the other
window forward; *M-<prior>* runs =scroll-other-window-down= and scroll
the other window backward. Other window is the window that you visit
when *C-x o*.

*C-x 0* closes the window at point.

*C-x 1* closes all other windows except the current selected
one. Create another window, then try *C-x 1*.

*C-x 4* is a common prefix for opening things in other buffer. Things
here can be files, shell, or a tree explorer. Here are standard *C-x
4* bindings:

|-------------+------------------------------------------------------------------|
| Key         | Binding                                                          |
|-------------+------------------------------------------------------------------|
| =C-x 4 C-f= | *Command*: =find-file-other-window=                              |
|             | Just like *find-file* discussed earlier, except open file        |
|             | in new window. If the current frame only has one window,         |
|             | a new window is created.                                         |
|-------------+------------------------------------------------------------------|
| =C-x 4 C-o= | *Command*: =display-buffer=                                      |
|             | Select a buffer from buffer list and display it in another       |
|             | window but not move point to that window.                        |
|-------------+------------------------------------------------------------------|
| =C-x 4 .=   | *Command*: =find-tag-other-window=                               |
|             | Open the tag at point in another window (more on this later)     |
|-------------+------------------------------------------------------------------|
| =C-x 4 0=   | *Command*: =kill-buffer-and-window=                              |
|             | Just like *C-x 0* but kill the buffer in that window as well.    |
|-------------+------------------------------------------------------------------|
| =C-x 4 a=   | *Command*: =add-change-log-entry-other-window=                   |
|             | Open another buffer and allow you to record the change of        |
|             | the current editing file. These days, you use version control    |
|             | system to manage file changes,and Emacs does this better.        |
|             | Probably this feature exists when thing like Git does not exist. |
|-------------+------------------------------------------------------------------|
| =C-x 4 b=   | *Command*: =switch-to-buffer-other-window=                       |
|             | Open a selected buffer in another window and move point to       |
|             | that window.                                                     |
|-------------+------------------------------------------------------------------|
| =C-x 4 c=   | *Command*: =clone-indirect-buffer-other-window=                  |
|             | Clone the current buffer in another window and give it a         |
|             | different buffer name.                                           |
|-------------+------------------------------------------------------------------|
| =C-x 4 d=   | *Command*: =dired-other-window=                                  |
|             | Open a *dired* buffer in another window. *Dired* is a built-int  |
|             | file manager in Emacs. We will discuss later.                    |
|-------------+------------------------------------------------------------------|
| =C-x 4 f=   | *Command*: =find-file-other-window=                              |
|             | Same as *C-x 4 C-f*                                              |
|-------------+------------------------------------------------------------------|
| =C-x 4 m=   | *Command*: =compose-mail-other-window=                           |
|             | Write mail in other window. You can write email and send it      |
|             | directly from Emacs.                                             |
|-------------+------------------------------------------------------------------|
| =C-x 4 r=   | *Command*: =find-file-read-only-other-window=                    |
|             | Similar to *find-file-other-window*, but open for read-only.     |
|-------------+------------------------------------------------------------------|
| =M-<next>=  | *Command*: =scroll-other-window=                                 |
|             | Scroll other window forward.                                     |
|-------------+------------------------------------------------------------------|
| =M-<prior>= | *Command*: =scroll-other-window-down=                            |
|             | Scroll the other window backward.                                |
|-------------+------------------------------------------------------------------|

That's quite a long table, eh? If you forget, you can either:

- Visit my manual again :)

- Or much faster, access it directly from Emacs with it amazing help
  system. So, if you want to know all key bindings to prefix *C-x 4*,
  just *C-x 4* and then *C-h*. If you enter a prefix key and enter
  *C-h* after it, it will list all of the key bindings and commands
  start with that prefix. This is really nice, compare to other
  editors that hide all this information deep within layers of menus.

Help system will be discussed in later section.

**** Prefix Arguments
:PROPERTIES:
:ID:       8bfeb59d-16e9-4ad5-9293-7fbb8135e510
:END:
In Emacs, behind anything is a function. Functions can accept
arguments. You can also pass arguments into Emacs commands to modify
its behaviours. However, you don't have to write code that calls
a function with its arguments and then compile or evaluate it. You can
pass arguments interactively.

*_Exercise_*:

Earlier, you learned motion commands such as *C-f*, *C-b*, *C-p* and
*C-n*, remember? But, you can only move forward 1 character with
*C-f*, move backward 1 character with *C-b*, 1 line upward with *C-p*
and 1 line downward with *C-n*.

Now, try *C-4* before any of those commands. See anything different?
Great, instead of executing the commands once (i.e. Move forward 1
character ...), you repeat the commands 4 times (i.e. Move forward 4
characters...).

Many commands allow multiple repetitions with prefix arguments.

You can even pass negative prefix arguments. Try executing the above
commands with *C--4*, that's right, *Control* and *-* and *4* (minus 4). You
see that you also execute the commands 4 times, but in /reverse/. That
is, with *C-f*, instead of moving forward 4 characters, you move
backward 4 times. You might wonder, what does it differ from *C-4
C-b*? You are right, it is the same. But, many commands do not have
their reversed versions, so negative argument is always useful in
those circumstances.

Now, try executing *C-u 4 C-f*. You will see it does the same thing as
*C-4 C-f*. Again, why do we need *C-u*? It is because in a terminal, you
can not use *Control* with digit keys. *C-u* tells Emacs that you are
about to enter a numeric argument, and it will be ready to accept the
input. It's just a different way to do thing.

If you do not supply any prefix argument, such as you directly execute
*C-u C-f*, then the numeric argument is default to *4*. Try *C-u
C-f*, and see that it moves 4 characters forward. Try it a few times
to get used to.

If you execute *C-u* consecutively, the numeric argument is a power
of 4. If you press *C-u*, the resulting argument is 4^1; *C-u C-u*,
the result is *4^2*, which is *16*; *C-u C-u C-u*, the result is
*4^3*, or *64*. I know large powers are hard to calculate, but there
is a plugin that displays the calculation and display these
numbers. That plugin is Helm, but I will discuss that later in part 2.

Why number 4 for *C-u*? I don't know.

**** Dired
***** Basic file management with Dired

Emacs has a built-in one called Dired, short for
=(Dir)ectory (Ed)itor=.

This section is a shortened version of Dired in GNU Emacs Manual. After
you read and practice these commands, read the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired Manual]] if possible.

***** Enter Dired


| Key         | Binding                                                             |
|-------------+---------------------------------------------------------------------|
| =C-x d=     | Select directory of your choice and start Dired in that directory   |
|-------------+---------------------------------------------------------------------|
| =C-x 4 d=   | Select directory of your choice and start Dired in another windows. |
|-------------+---------------------------------------------------------------------|
| =C-x C-f=   | Select a directory to enter Dired                                   |
|-------------+---------------------------------------------------------------------|

*_Exercise_*: Execute the above commands at least once to get used to
it. What command do you like the most?

***** Navigation
:PROPERTIES:
:ID:       63b35a41-7ec7-4ee5-8f40-f189be084488
:END:
| Key   | Binding                                                        |
|-------+----------------------------------------------------------------|
| =n=   | Move to next entry below point.                                |
|-------+----------------------------------------------------------------|
| =p=   | Move to previous entry above point.                            |
|-------+----------------------------------------------------------------|
| =C-s= | Find text using Isearch; useful for searching entries in Dired |
|-------+----------------------------------------------------------------|

You can supply prefix arguments for these commands. i.e. =4 n= moves
to the entry which is 4 lines below.

*_Exercise_*: Execute the above commands, with and without prefix argument.

***** Create files

To create a new file in Dired, you use the same *C-x C-f* and *C-x 4
C-f* variant.

| Key       | Binding                                                  |
|-----------+----------------------------------------------------------|
| =+=       | Prompts for a directory name and create one after *RET*. |
|-----------+----------------------------------------------------------|
| =C-x C-f= | Create a new file. This is your regular =find-file=.     |
|-----------+----------------------------------------------------------|

*_Exercise_*:

- Create a new directory called =dired_practice= or a name of your
  choice.
- Create a new file of your choice.
***** Visit files

| Key                 | Binding                                                                   |
|---------------------+---------------------------------------------------------------------------|
| =f= or =e= or =RET= | Open current file at point.                                               |
|---------------------+---------------------------------------------------------------------------|
| =o=                 | Open file at point in another window.                                     |
|---------------------+---------------------------------------------------------------------------|
| =C-o=               | Open file at point in another window, but do not select that window.      |
|---------------------+---------------------------------------------------------------------------|
| =v=                 | Open file for read only.                                                  |
|---------------------+---------------------------------------------------------------------------|
| =^=                 | Open parent directory and create another Dired buffer of parent directory |
|---------------------+---------------------------------------------------------------------------|

*_Exercise_*:
- Assume you are in your newly created directory in previous section.
- Go up to the parent directory using =^=.
- Open another directory. You will enter that directory, and a new
  buffer is created for listing the content of that directory.
- Go up to the parent directory using =^=.
- Repeat opening and go up parent directory a few times.
- *C-x b* and *TAB*. You will see a bunch of opened directory through
  your filesystem navigation. Whenever you open a file or directory,
  using Dired or other methods, you have a buffer of that directory.

  At this point, you may feel annoyed that Dired opens too many
  buffers and it will go out of control at some point. Worry not!
  That's why you have =ibuffer=.

- =M-x ibuffer= or =C-x C-b= if you've already replaced =list-buffers=.
- =/ m= and select =dired-mode=. =/ g= and name the group =Dired= and
  you have a separate group for managing directories. No more
  cluttered view with other buffers. You can stop worrying now.

  [[https://tuhdo.github.io/static/ibuffer-dired-group.gif]]

  If you  want to enter directory you visited, open =ibuffer= and
  look for it. This is efficient for a complex directory tree. For
  example, if you have to constantly work with these many directories:

  - =directory_root/dir1/dir2/dir3/dir4/=
  - =directory_root/dir2/dir2/dir3/dir4/=
  - =directory_root/dir5/dir6/dir7/dir8/=
  - ....

  The layouts of top two directories are common when you have to
  create patches. Working in a normal file manager like File Explorer
  in Windows, you only have one directory view. Going back and forth
  is tedious and inefficient, and you have to remember different
  directory paths. To make it easy, you have to open multiple File
  Explorer manually. Under the terminal, you have to create symbolic
  links for those directories to save you time. However, you still
  have to manage the links manually, like delete when they are not
  used, or update when directory the links pointing to are moved.

  Emacs does it all for you, /automatically/. With this feature, you
  can freely navigate the filesytem without having to remember the
  working directory to get back later, because you can easily go back
  to it quick and easy.

***** File Marking

You flag files for deletion. You mark files for everything else
(i.e. copy, move, link files...). There are many marking commands for
specialized file types. Except for *m*, *% m* and *% g*, all marking
commands have prefix =*=. I will list the most useful one; you can
look up the other marking commands in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Marks-vs-Flags.html#Marks-vs-Flags][Dired Manual]].

| Key   | Binding                                                     |
|-------+-------------------------------------------------------------|
| =m=   | mark the entry at point. You can mark more than one, either |
|       | downward or upward with prefix argument.                    |
|-------+-------------------------------------------------------------|
| =% m= | mark all files whose names match supplied regexp.           |
|-------+-------------------------------------------------------------|
| =% g= | match all files whose contents match the supplied           |
|       | regexp. This is the same as using *Grep*.                   |
|-------+-------------------------------------------------------------|

*_Exercise_*: Practice the listed marking commands. Keep a few marked
files/directories for the next section.

***** Operating on files

These commands use uppercase character. If you see an uppercase
character for a command, it means *S-<character>*.

| Key | Binding                                                      |
|-----+--------------------------------------------------------------|
| =C= | Prompt for a location to copy the file at point (if no file  |
|     | is marked) or marked files.                                  |
|-----+--------------------------------------------------------------|
| =R= | Prompt for a location to rename or move file at point (if no |
|     | file is marked) or marked files. This is the same as =mv=    |
|     | command in shell.                                            |
|-----+--------------------------------------------------------------|
| =H= | Prompt for a location to create a hard link.                 |
|-----+--------------------------------------------------------------|
| =S= | Prompt for a location to create a symbolic link.             |
|-----+--------------------------------------------------------------|
| =M= | Change permission bits of file at point or marked files.     |
|-----+--------------------------------------------------------------|

*_Exercise_*:
- Create a new directory at the current directory.
- Assume that your still keep the marked file in the above section;
  =C= and prompt for the directory you have created. *RET* to confirm
  copying.
- If you want to move marked files/directories, use =R=. If you want
  to rename, mark only a single file/directory and put a new name in
  the rename prompt.
- Enter the directory you have just copied the files.
- Move your cursor on a file and =H= to create a hard link. A prompt
  ask for destination and the link name. Create a link at the current
  location with different name from the original file.
- Move your cursor on a file and =S= to create a symolic link. A prompt
  ask for destination and the link name. Create a link at the current
  location with different name from the original file.
- Move your cursor on either the hardlink or symlink you created and
  =M= and change the bit permission; set it to something like =000=.
- After that, press =g= to refresh the Dired buffer. Look at the
  original files the links point to, you will see the permission
  attributes are cleared and you won't be able to access those files.

***** Deleting files

| Key    | Binding                                                              |
|--------+----------------------------------------------------------------------|
| =d=    | flags file for deletion.                                             |
|--------+----------------------------------------------------------------------|
| =u=    | remove flagged files.                                                |
|--------+----------------------------------------------------------------------|
| =#=    | flag all auto-save files (files whose names start and end with ‘#’). |
|--------+----------------------------------------------------------------------|
| =~=    | flag all backup files                                                |
|--------+----------------------------------------------------------------------|
| =% &*= | flag for deletion all files that match =dired-garbage-files-regexp=. |
|--------+----------------------------------------------------------------------|
| =% d=  | flag files which matches a regexp.                                   |
|--------+----------------------------------------------------------------------|
| =x=    | confirm and delete flagged files.                                    |
|--------+----------------------------------------------------------------------|

***** Execute shell commands in Dired

Just like in a shell, you can execute commands in the current
directory in Dired too.

| Key | Binding                                                     |
|-----+-------------------------------------------------------------|
| =!= | execute a command on selected file or files.                |
|-----+-------------------------------------------------------------|
| =&= | execute a command on selected file or files asynchronously. |
|-----+-------------------------------------------------------------|

***** Compare files

| Key | Binding                                                            |
|-----+--------------------------------------------------------------------|
| *=* | compares the file at point with another file supplied by user from |
|     | a file prompt in the minibuffer.                                   |
|-----+--------------------------------------------------------------------|

***** Subdirectories

This is an exciting feature of Dired. In other file explorers, you get
a tree to browse your directory. If you have a deep directory
structure, it will quickly become a nuisance.

Dired allows user to insert the content of a directory just below the
current directory. You can search for file names with *C-s* easily in
both directories. You can insert as many subdirectories as you want.

Move point on a directory in Dired and press *i*. You will see another
directory insert below:

[[https://tuhdo.github.io/static/dired-subdir.gif]]

This is really efficient when you work on several related directories in
a project frequently.

*_Exercise_*:

- Open a directory with subdirectories inside it.
- Insert subdirectories with *i*.
- Remember Bookmark? You can save Dired buffers with Bookmark for
  later access. *C-x r m* and save the current Dired buffer with subdirectories.
- Kill the current Dired buffer with subdirectories.
- Open the Dired buffer via the bookmark list *C-x r l*. You will see
  that not only your Dired buffer is fully restored, but your
  subdirectories too.

**** Registers

When I first heard about registers in Emacs, it scared me. I thought
"Wow, what is this "register" thing? Am I going to work directly with
CPU registers?" As it turned out, despite the name "Register", it's
not something that complicated to understand. Although, an Emacs
register is similar to a CPU register in the sense that it allows
quick access to temporal data.

Each register has a name that consists of a single character, which we
will denote by /r/; /r/ can be a letter (such as ‘a’) or a number (such as
‘1’); case matters, so register ‘a’ is not the same as register ‘A’.

In Emacs, registers are for quick access to things. Things can be a
position, a piece of text, a rectangle, a number, a file name, or a
window configuration (yes, you can save how Emacs organizes its
screens and restore it later!).

Saving different types of objects has different key bindings, but to jump
to a register, you use a single command *C-x r j REG*; *REG* is a
register of your choice.

The prefix key for register commands is *C-x r*. If you forget the key
bindings, *C-x r C-h* to get the list of key bindings.

***** Save window configuration
:PROPERTIES:
:ID:       840ff6ae-1f2b-4796-9f7f-7cd5db33d879
:END:
One of the best uses of registers. It simply saves your current window
configuration and restores the layout later.

For example, you are viewing four source code buffers, but want to
open two Dired buffers side by side to for managing files, so you
close two windows and switch the other two windows to Dired
buffers. But this makes you lose the perfect layout you had, and later
it would be tedious to restore the windows one by one to finally
recreate the original layout you were working with. Then, later, you
have to do something else, you have to break your window
configuration, you have to manually restore your window configuration
again, and have to remember exactly which buffers you were working
with.

To free yourself from this burden, register is the answer. You can
save a window configuration with four windows displaying four buffers,
and another one having two Dired buffers for your project. You can
more easily switch between them.

| Key           | Binding                                                                      |
|---------------+------------------------------------------------------------------------------|
| *C-x r w REG* | *Command*: =window-configuration-to-register=                                |
|               | Save the window configuration of current frame into register *REG*           |
|---------------+------------------------------------------------------------------------------|
| *C-x r f REG* | *Command*: =frame-configuration-to-register=                                 |
|               | Save the state of all frames, including all their windows, in register *REG* |
|---------------+------------------------------------------------------------------------------|
| *C-x r j REG* | *Command*: =jump-to-register=                                                |
|               | Jump to a register *REG*.                                                    |
|---------------+------------------------------------------------------------------------------|

*REG* can be a letter (such as ‘a’) or a number (such as ‘1’); case
 matters, so register ‘a’ is not the same as register ‘A’.

_Demo_: In this demo, I saved two windows configurations in two
registers *a* and *b*, using *C-x r w*. Register *a* stores the Dired
buffer that contains two project directories. Then, I open two files
in the two directories, create another smaller window and open another
file. Then, suddenly I want to go back to my project roots. It's then
when I execute *C-x r j*, get a prompt, enter *a* and Emacs switches
back the Dired buffer. Then, I switch back to the files I was editing
with *C-x r j*, get a prompt, enter *b*.

The demo starts when you see at the bottom a prompt with "Eval: START".

[[file:static/register-windows.gif][file:static/register-windows.gif]]

*_Exercise_*:

- Save a few window configurations into registers. I suggest that each
  window configuration should represent a workspace of a project. But
  it could be anything you like, up to your imagination.

- Go back and forth between window configurations by jumping into
  appropriate registers.

***** Save frame configuration
:PROPERTIES:
:ID:       7ecf0eed-367e-4e8c-8230-aee169a225c3
:END:

| Key           | Binding                                              |
|---------------+------------------------------------------------------|
| *C-x r f REG* | Save current frame configuration into register *REG* |
|---------------+------------------------------------------------------|

If you create multiple frames with frame commands (prefix *C-x 5*),
then you may want to save your frames with different window
configurations in it, for later use. For example, I can have a frame
for reading documents and my main frame for writing and browsing
code. When I finish working, I close the extra frame, leaving my main
frame active. But later, when I need to have that exact frame setup, I
can always restore with saved frameset in a register.

*_Exercise_*:

- Create a few frames with *C-x 5 2*, *C-x 5 d*, *C-x 5 f*...
- Save the frameset into a register.
- Close all the frames except the main one.
- Restore the frames by jumping to the register that stores the
  frameset.

***** Save text
:PROPERTIES:
:ID:       cf4d74d8-e13e-4238-a5ff-9de0f006b6c5
:END:
You can also save a region in registers.

| Key           | Binding                         |
|---------------+---------------------------------|
| *C-x r s REG* | *Command*: =copy-to-register=   |
|               | Copy region into register *REG* |
|---------------+---------------------------------|
| *C-x r i REG* | *Command*: =insert-register=    |
|               | Insert text from register *REG* |
|---------------+---------------------------------|

*REG* can be a letter (such as ‘a’) or a number (such as ‘1’); case
 matters, so register ‘a’ is not the same as register ‘A’.

You may wonder, what's the point of storing text into register? Haven't
you got a kill ring? Here are the reasons:

- As you already know, inserting past content from the kill ring makes
  the chosen content the head entry. This is inconvenient, and this is
  when registers are handy for storing many pieces of text without
  affecting the kill ring. For example, you read a manual (man page or
  info page), and you want to remember many keywords and paste it
  somewhere later. Registers can help you with this use case.

- You can also use registers to save many code templates. For example,
  you can save a for loop template into register *f*, if template into
  register *i*, function definition into register *F*... This is
  really handy when you are learning a new language and keep
  forgetting syntax all the time.

  For example, this C++11 code snippet would be hard to remember if
  you are new:

  #+begin_src c++
    auto it = find_if (vertices.begin(), vertices.end(), [&v_idx] (const Vertex& o) -> bool {
	    return o.id == v_idx;
	});
  #+end_src

  I save it to a register, insert and modify it to fit my current need
  until I remember it. This is much faster than to go back to the
  previous source location to look it up again, and would be time
  consuming if your source code is large.

*_Exercise_*:

- Copy a few text snippets into registers.
- Re-insert it in a buffer.

***** Save rectangles
:PROPERTIES:
:ID:       a9136910-960b-4561-8155-1ccc8fb0bb29
:END:

| Key           | Binding                                       |
|---------------+-----------------------------------------------|
| *C-x r r REG* | Command: =copy-rectangle-to-register=         |
|               | Copy the region-rectangle into register *REG* |
|               | With *C-u* prefix, delete it as well          |
|---------------+-----------------------------------------------|

Insert the rectangle in register *REG* by *C-x r i REG*.

*_Exercise_*:

- Save a few rectangles in registers a few times to get used to it.
- Insert the rectangles in the registers into some buffer.

**** Save position

| Key               | Binding                                                              |
|-------------------+----------------------------------------------------------------------|
| *C-x r <SPC> REG* | Command: =point-to-register=                                         |
|                   | Record the position of point and the current buffer in register REG  |
|-------------------+----------------------------------------------------------------------|
| *C-x r j REG*     | Command: =jump-to-register=                                          |
|                   | Jump to the position and buffer saved in register REG. If the buffer |
|                   | is killed, revisit the file and open the buffer, then jump.          |
|-------------------+----------------------------------------------------------------------|

Saving positions are useful when it is used with Macro, which is
discussed later.

*_Important Note_*:

When you jump to a position into a register, Emacs *always* jumps to
that position, even if the content of the buffer is changed. That is,
if you already saved a position into a register and when the buffer
that holds that position changes, the saved position changes as
well. For example, you save position 100 (it means the position of
100th character) and you add or remove a number of characters before
the 100th character, then the position in the saving register also add
or subtract according to that number.

*_Exercise_*:

- Save a buffer position into register *a* with *C-x r SPC a*.
- Move point else where.
- Jump back to previous position with *C-x r j a*.
- Move point backward a few characters.
- Add some characters.
- Jump back to position in register *a* with *C-x r j a*.
- You see that point does not jump to original position, but away from
  the original position a number of characters that is equal to the
  number of your added characters.
- Go to the beginning of line and *RET* to add a newline.
- Jump back to position in register *a* with *C-x r j a*.
- You see that point jumps to position in register *a*, but one line
  below.

**** Save numbers
:PROPERTIES:
:ID:       050dfff1-d8b1-4de0-b1c2-8aa6fcff79ee
:END:

| Key                      | Binding                                   |
|--------------------------+-------------------------------------------|
| *C-u number C-x r n REG* | Command: =number-to-register=             |
|                          | Store /number/ into register *REG*        |
|--------------------------+-------------------------------------------|
| *C-u number C-x r + REG* | Command: =increment-register=             |
|                          | If *REG* contains a number, increment the |
|                          | *number* in that register by number.      |
|--------------------------+-------------------------------------------|

You can insert the number from a register *REG* with *C-x r i
REG*. These numbers are handy when used with =Keyboard Macro=.

*_Exercise_*:

- Save a few numbers into registers.
- Add a number of your choice into numbers saved in the registers.
- Insert back the number in registers into a buffer, and see the
  result.

**** Macro
:PROPERTIES:
:ID:       7a1827f6-3bcf-4ff4-92a3-44bf0aae9ab9
:END:
Macro records your actions in Emacs and play back later.

| Key             | Binding               |
|-----------------+-----------------------|
| =f3= or =C-x (= | Start recording macro |
|-----------------+-----------------------|
| =f4= or =C-x )= | Stop recording macro  |
|-----------------+-----------------------|
| =C-x e= or =f4= | Playback macro        |
|-----------------+-----------------------|

Personally, I use =f3= and =f4= for recording/playback, so I don't
have to press many keys. To repeat a macro many times, use prefix
argument. For example, =C-u 10 <f4>= executes a macro 10 times. If you
want to cancel recording, *C-g*.

*_Exercise 1_*:

Copy these lines into a buffer of your choice:

#+begin_src fundamental
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
  aaaaabbbbbbbccccccdddddd
#+end_src

Now, you want to separate each line into different groups, each group
contains their own character, like this:

#+BEGIN_HTML
aaaaa bbbbbbb cccccc dddddd
#+END_HTML

In many editors, you have have to do it manually. In Emacs, you don't
have to repeat yourself, using macro. Follow these steps:

- Place point at the beginning of the first line.
- Press *<f3>*.
- Use C-s to search-and-jump to the beginning of each character group (or C-f if you want something simple) and add whitespace.
- Return to the beginning of next line. Press *<f4>* to finish recording.
- Continuously press *<f4>* and see Emacs playbacks the whole action
  sequence you've just recorded.
- If you want to repeat more than 1 time, using prefix argument. If
  you want to repeat until the end of file, use prefix argument 0:
  *C-u 0 <f4>*. Alternatively, highlight the region of remaining
  lines, and *C-x C-k r*: run the last keyboard macro on each line
  that begins in the region (=apply-macro-to-region-lines=).

[[https://tuhdo.github.io/static/macro.gif]]

After a macro is defined, it is saved in the keyboard macro ring. There is
only one keyboard macro ring, shared by all buffers. All commands
which operate on the keyboard macro ring use the same *C-x C-k*
prefix. Just remember the prefix *C-x C-k* = macro commands, and you
won't find macro key bindings difficult to remember.

*_Exercise 2_*: Transform data from one format to another

For example, I have this table with some data:

#+begin_src fundamental
  machine1=(aa:bb:cc:dd:ee:a1 aa:bb:cc:dd:ee:a2 aa:bb:cc:dd:ee:a3)
  machine2=(aa:bb:cc:dd:ee:b1 aa:bb:cc:dd:ee:b2 aa:bb:cc:dd:ee:b3)
  machine3=(aa:bb:cc:dd:ee:c1 aa:bb:cc:dd:ee:c2 aa:bb:cc:dd:ee:c3)
  machine4=(aa:bb:cc:dd:ee:d1 aa:bb:cc:dd:ee:d2 aa:bb:cc:dd:ee:d3)
  machine5=(aa:bb:cc:dd:ee:e1 aa:bb:cc:dd:ee:e2 aa:bb:cc:dd:ee:e3)
  machine6=(aa:bb:cc:dd:ee:f1 aa:bb:cc:dd:ee:f2 aa:bb:cc:dd:ee:f3)
#+end_src

Basically, each row contains the MAC addresses of Ethernet interfaces
of a machine in the server cluster at my workplace. The data are
stored in a plain text file. But then, we want to integrate these data
inside our YAML file to do something else. I have to basically
transform the data in the above format to the one below:

#+begin_src yaml
  machine 1:
      mac1: aa:bb:cc:dd:ee:a1
      mac2: aa:bb:cc:dd:ee:a2
      mac3: aa:bb:cc:dd:ee:a3
#+end_src

In the real data file, it contains around 50 entries. Manually
transforming text would be tiresome. Thanks to Emacs, I solved this
problem with a keyboard macro.

- _Pre-recording setup_:
  Before recording a macro to automate this transformation, we need to
  properly set things up:

  - Create two buffers side by side with *C-x b*. Name the left buffer
    =buf1= and right buffer =buf2=.
  - Yank the original data into =buf1=. Move point back to
    beginning of buffer.

    That's set and done. Here is how it should look like:

    [[https://tuhdo.github.io/static/prepare_macro.gif]]

- _Record_:

   Point should be at =buf1=, at the first line of the data.

  - Press *<f3>* to start.
  - *C-SPC* then *M-f*. This marks the word =machine1=. Store this word
    into register =a= with *C-x r s a*.

    [[https://tuhdo.github.io/static/reg_a.gif]]

  - Move point to the beginning of the first MAC address. *C-SPC* then
    *C-s* and search to the first delimiter, which is an empty space "
    " in this case. *C-b* to move back to the end of the first MAC
    address. Store this region into register *b* with *C-x r s b*.

    [[https://tuhdo.github.io/static/reg_b.gif]]

  - After that, move point to the beginning of the 2nd MAC address,
    *C-s* to space and *C-b* to go back one character. Save the region
    into register *c* with *C-x r s c*.

    [[https://tuhdo.github.io/static/reg_c.gif]]

  - Repeat for the last MAC address and save it in register *d*.

    [[https://tuhdo.github.io/static/reg_d.gif]]

  - Switch to the second buffer with *C-x o*:
  - Insert the register from =a= to =d= according to the template:

    [[https://tuhdo.github.io/static/insert_buf2_macro.gif]]

  - After inserting, move point to the next empty line.
  - Switch back to =buf1= with *C-x o*.
  - Move to the beginning of next line.
  - Press *<f4>* to stop.

- _Play_:

  Now you can play back your new keyboard macro to transform the
  remaining entries.

Here is the whole process:

[[https://tuhdo.github.io/static/macro2_full.gif]]

**** Keyboard macro ring

| Key           | Binding                                              |
|---------------+------------------------------------------------------|
| *C-x C-k C-k* | Command: =kmacro-end-or-call-macro-repeat=           |
|               | Execute the keyboard macro at the head of the ring   |
|---------------+------------------------------------------------------|
| *C-x C-k C-n* | Command: =kmacro-cycle-ring-next=                    |
|               | Rotate the keyboard macro ring to the next macro     |
|               | (defined earlier).                                   |
|---------------+------------------------------------------------------|
| *C-x C-k C-p* | Command: =kmacro-cycle-ring-previous=                |
|               | Rotate the keyboard macro ring to the previous macro |
|               | (defined later)                                      |
|---------------+------------------------------------------------------|

*_Exercise_*:

Define a few more keyboard macros and practice the above commands.

**** The Keyboard Macro Counter
:PROPERTIES:
:ID:       8f80bf88-4b37-425f-8e55-d57c38a3c311
:END:
Each macro has a counter which is initialized to 0. Everytime a
counter is inserted into the buffer, its value is incremented by 1.

| Key           | Binding                                                     |
|---------------+-------------------------------------------------------------|
| *<f3>*        | Command: =kmacro-start-macro-or-insert-counter=             |
|               | Insert the counter into the buffer and increase the counter |
|               | by 1. This is only applicable when a macro is recording     |
|---------------+-------------------------------------------------------------|
| *C-x C-k C-i* | Command: =kmacro-insert-counter=                            |
|               | Insert the counter of current macro into the buffer         |
|---------------+-------------------------------------------------------------|
| *C-x C-k C-c* | Command: =kmacro-set-counter=                               |
|               | Change the counter value of current macro                   |
|---------------+-------------------------------------------------------------|
| *C-x C-k C-a* | Command: =kmacro-add-counter=                               |
|               | Add a number to the current keyboard macro counter. *C-u*   |
|               | before running this command resets the counter back to      |
|               | previous value                                              |
|---------------+-------------------------------------------------------------|
| *C-x C-k C-f* | Command: =kmacro-set-format=                                |
|               | Specify the format for inserting the keyboard macro counter |
|---------------+-------------------------------------------------------------|

Valid format specifications for *C-x C-k C-f*:

| Specification | Description                                                                          |
|---------------+--------------------------------------------------------------------------------------|
| =%o=          | Insert *base-eight* representation of an integer.                                    |
|---------------+--------------------------------------------------------------------------------------|
| =%d=          | Insert *base-ten* representation of an integer.                                      |
|---------------+--------------------------------------------------------------------------------------|
| =%x=          | Insert *base-sixteen* representation of an integer.                                  |
| =%X=          | ‘%x’ uses lower case and ‘%X’ uses upper case.                                       |
|---------------+--------------------------------------------------------------------------------------|
| =%c=          | Insert the character which is the numerical value given.                             |
|---------------+--------------------------------------------------------------------------------------|
| =%e=          | Insert exponential notation for a floating point number.                             |
|---------------+--------------------------------------------------------------------------------------|
| =%f=          | Insert decimal-point notation for a floating point number.                           |
|---------------+--------------------------------------------------------------------------------------|
| =%g=          | Insert notation for a floating point number, using either exponential notation or    |
|               | decimal-point notation, whichever is shorter.                                        |
|---------------+--------------------------------------------------------------------------------------|
| =%%=          | Insert a single ‘%’. This format specification is unusual in in that it does not use |
|               | a value. For example, (format "%% %d" 30) returns "% 30".                            |
|---------------+--------------------------------------------------------------------------------------|

The format must contain at least one of the valid specification above
or combination with other text. For example, these are valid format:

- =0x%x=
- =Project %d:=
- =Plain text=

*_Exercise 1_*: Creating incremental header prefix

Format specification is useful for making formatted output with macro,
combine with the counter, it is useful for appending numbered prefix
at beginning of line. For example: We usually write code comment that
describes sequential steps in a high level point of view like this:

#+begin_src fundamental
  - Step 1 of 5: ...
  - Step 2 of 5: ...
  - Step 3 of 5: ...
  - Step 4 of 5: ...
  - Step 5 of 5: ...
#+end_src

Keyboard macro can help us generate such text pattern effortlessly.

- *C-x C-k C-f* and enter this format: =- Step %d of 5:=
- *<f3>* to start recording.
- *<f3>* again to insert the first counter value, which is =- Step 0
  of 5:=
- *RET* to move to the next line.
- *<f4>* to stop recording.
- Now press *<f4>* as many time as you want and see header prefix got
  inserted with incremental values.
- You can insert the text any value by simply set the counter with
  *C-x C-k C-c*.

Remember to use this the next time you write comments for your code
that need an ordered list to describe the steps of your algorithm.

*_Exercise 2_*: Generate a list of numbers

With macro counter, you can easily generate a list of number in
supported base:

- *C-x C-k C-f* and enter a format like this: =%d= (or a base number
  of your choice).
- Initialize the macro counter to a number of your choice.
- *<f3>* to start recording.
- If you want the numbers to be 5 units (or any number greater than 1)
  apart from each other, *C-x  C-k a* to add a number to the
  counter. If you only want to increase by 1, skip this step because
  the default is 1.
- *<f3>* to insert the first number.
- *SPC* to create a separator.
- *<f4>* to stop recording.
- Now *<f4>* repeatedly to see numbers getting generated.

**** Macros with Variations
:PROPERTIES:
:ID:       29ef199d-1fc8-49e5-aee8-a8b2e7c69b6c
:END:
Macro is excellent for repetitive editing tasks. However, sometimes
you have a repetitive task that can make use of macro, but not always
repetitive: a part of the task varies every time you repeat it. For
example, you have a text template, with some blank fields for fitting
in appropriate information. Keyboard macro supports this use case.

When in the process of defining a keyboard macro, *C-x q* marks the
current point in the process, and when the keyboard macro is executed
and reaches this point, it will ask to confirm:

| Response | Action                                                        |
|----------+---------------------------------------------------------------|
| *Y*      | Finish this iteration normally and continue with the next.    |
|----------+---------------------------------------------------------------|
| *N*:     | Skip the rest of this iteration, and start the next.          |
|----------+---------------------------------------------------------------|
| *RET*    | Stop the macro entirely right now.                            |
|----------+---------------------------------------------------------------|
| *C-l*    | Redisplay the screen, then ask again.                         |
|----------+---------------------------------------------------------------|
| *C-r*    | Start editing at point. *C-M-c* to go back to macro execution |
|----------+---------------------------------------------------------------|

*_Exercise_*: Inserting interactive template

Suppose you practice Agile and have to write a lot of user stories
like this:

#+BEGIN_QUOTE
*As a* <type of user>, *I want* <some goal> *so that* <some reason>.
#+END_QUOTE

Obviously, you do not want to repeat the template texts, such as "As
a", "I want" or "so that". The only contents that varies are =<type of
user>=, =<some goal>= and =<some reason>=. You can create a macro that
stops and waits for your action at these checkpoints. *C-r* to start
editing.

- First, copy this template:

#+begin_src fundamental
  As a , I want , so that
#+end_src

- *<f3>* to start recording.
- *C-y* to yank the template.
- Move point to positions that need modifications, then *C-x q*.
- *<f4>* to stop recording.
- Now *<f4>* and you will see the macro stops at the positions where
  you pressed *C-x q* before and ask for your action.
- *C-r* to edit. After done editing, *C-M-c* to go back.
- You are asked the same question as before. If you still miss
  something, *C-r* to edit again. Otherwise, press *y* to proceed to
  the next point.
- Continue until the end of macro.

**** Naming and Saving Macro

| Key         | Binding                                                         |
|-------------+-----------------------------------------------------------------|
| *C-x C-k n* | Command: =kmacro-name-last-macr=                                |
|             | Give a command name (for the duration of the Emacs session)     |
|             | to themost recently defined keyboard macro.                     |
|-------------+-----------------------------------------------------------------|
| *C-x C-k b* | Command: =kmacro-bind-to-key=                                   |
|             | Bind the most recently defined keyboard macro to a key sequence |
|             | (for the duration of the session)                               |
|-------------+-----------------------------------------------------------------|

When macro has a name, it becomes a command and you can find it in
*M-x* and can be saved with =M-x insert-kbd-macro=. After executing
the command, you are prompted for a macro name (you can use *TAB* to
complete the name); select a macro and the Lisp code of the chosen
macro is inserted into the current buffer, then save the buffer. You
should have a dedicated file for your own keyboard macros. You can
reload this file for later Emacs session with the command
=load-file=.

You can also bind a macro to any key sequence. However, to avoid
clashing with existing key bindings, you should use the prefix *C-x
C-k*. For example, you can bind a macro to *C-x C-k 1*, another to
*C-x C-k 2*...

*_Exercise 1_*: Save your macro in a file

- Record some keyboard macros.
- Give the macros names with *C-x C-k n*.
- Bind the macros to *C-x C-k 1*, *C-x C-k 2*... with *C-x C-k b*.
- Create the file =~/.emacs.d/init.el=. If you do not have the
  directory and the file, create it with =find-file=.
- Create the file =~/.emacs.d/macros= with =find-file=. You should be
  inside the buffer of this file after creating it.
- Save the macros with =M-x insert-kbd-macro=.
- To save you trouble of reloading the macro file manually, put this
  Emacs Lisp code inside =~/.emacs.d/init.el=:

  #+begin_src emacs-lisp
    ;(load-file "~/.emacs.d/macros")
  #+end_src

  The above code essentially loads a file at a path. Only files that
  are Emacs Lisp source code are valid.

- Now, every time Emacs starts, it will automatically load the
  =macros= file. By default, Emacs loads any Emacs Lisp code at
  =~/.emacs.d/init.el= when it starts. Since you put the above code in
  =init.el=, your =macros= file is also loaded.

*_Exercise 2_*: Composite macros

Back to exercise 2 at the beginning of Macro section, do you remember
you had to create a big macro to convert text structures? Certainly it
can be done more comfortably by splitting it into smaller macros,
saving these macros into Emacs commands and putting them all together
in a macro.

- _Pre-recording setup_:
  Before recording a macro to automate this transformation, we need to
  properly set things up:

  - Create two buffers side by side with *C-x b*. Name the left buffer
    =buf1= and right buffer =buf2=.
  - Yank the original data into =buf1=, then move point back to
    beginning of buffer:

#+begin_src fundamental
  machine1=(aa:bb:cc:dd:ee:a1 aa:bb:cc:dd:ee:a2 aa:bb:cc:dd:ee:a3)
  machine2=(aa:bb:cc:dd:ee:b1 aa:bb:cc:dd:ee:b2 aa:bb:cc:dd:ee:b3)
  machine3=(aa:bb:cc:dd:ee:c1 aa:bb:cc:dd:ee:c2 aa:bb:cc:dd:ee:c3)
  machine4=(aa:bb:cc:dd:ee:d1 aa:bb:cc:dd:ee:d2 aa:bb:cc:dd:ee:d3)
  machine5=(aa:bb:cc:dd:ee:e1 aa:bb:cc:dd:ee:e2 aa:bb:cc:dd:ee:e3)
  machine6=(aa:bb:cc:dd:ee:f1 aa:bb:cc:dd:ee:f2 aa:bb:cc:dd:ee:f3)
#+end_src

    That's set and done. Here is how it should look like:

    [[file:static/prepare_macro.gif][file:static/prepare_macro.gif]]

- _Record_:

  Point should be at =buf1=, at the first line of the data. Let's
  create the first macro command, =save-macs= that saves the
  information of each entry into registers a,b,c,d:

  - *<f3>* to start.
  - *C-SPC* then *M-f*. This mark the word =machine1=. Store this word
    into register =a= with *C-x r s a*.

    [[file:static/reg_a.gif][file:static/reg_a.gif]]

  - Move point to the beginning of the first MAC address. *C-SPC* then
    *C-s* and search to the first delimiter, which is an empty space "
    " in this case. *C-b* to move back to the end of the first MAC
    address. Store this region into register *b* with *C-x r s b*.

    [[file:static/reg_b.gif][file:static/reg_b.gif]]

  - After that, move point to the beginning of the 2nd MAC address,
    *C-s* to space and *C-b* to go back one character. Save the region
    into register *c* with *C-x r s c*.

    [[file:static/reg_c.gif][file:static/reg_c.gif]]

  - Repeat for the last MAC address and save it in register *d*.

    [[file:static/reg_d.gif][file:static/reg_d.gif]]

  - Move point to the beginning of next line.

  - *<f4>* to stop. *C-x C-k n* and save the macro with the name
    =save-macs=.

  Let's create the second macro command, =insert-macs=:

  - Switch to the second buffer with *C-x o*:
  - *<f3>* to start recording.
  - Insert the register from =a= to =d= according to the template:

    [[file:static/insert_buf2_macro.gif][file:static/insert_buf2_macro.gif]]

  - After inserting, move point to the next empty line.
  - *<f4>* to stop. *C-x C-k n* and save the macro with the name =insert-macs=.

 We have two important macros now. Let's put them back together:

  - Switch back to =buf1= with *C-x o*. Point should be on the second
    entry.
  - *<f3>* to start recording.
  - =M-x save-macs=; after executing this command, point moves to the
    next line.
  - *C-x o* to switch to =buf2=. Point should be after the first
    insertion of =machine1=.
  - =M-x insert-macs=; data get inserted into the buffer after this
    command.
  - *C-x o* to switch back to =buf1=.
  - Press *<f4>* to stop.

- _Play_:

  You can play back your new keyboard macro to transform the
  remaining entries.

**** Edit Keyboard Macro
:PROPERTIES:
:ID:       e757ddcb-6453-4dad-b6a7-ce66ea6b4ffb
:END:

| Key                    | Binding                                           |
|------------------------+---------------------------------------------------|
| *C-x C-k C-e*          | Command: =kmacro-edit-macro=                      |
|                        | Edit the last defined keyboard macro              |
|------------------------+---------------------------------------------------|
| *C-x C-k e name <RET>* | Command: =edit-kbd-macro=                         |
|                        | Edit a previously defined keyboard macro name     |
|------------------------+---------------------------------------------------|
| *C-x C-k l*            | Command: =kmacro-edit-lossage=                    |
|                        | Treat the last 300 keystrokes as a keyboard macro |
|------------------------+---------------------------------------------------|

It is useful to edit a keyboard macro when you run an incorrect
command. Instead of doing the whole thing again, you can edit the
incorrect part. Note that, do not press *C-g* or you will kill your
current recording macro; press *<f4>* instead to complete the macro,
and edit it. After you're done editing, continue from the previous
point where you left off with:

- *C-u <f3>*: Re-execute last keyboard macro, then append keys to its
  definition.
- *C-u C-u <f3>*: Append keys to the last keyboard macro without
  re-executing it.

**** Interactive Keyboard Macro Editing:
:PROPERTIES:
:ID:       03e7f694-5647-452b-8fc7-8f88180b29ab
:END:
*C-x C-k SPC* runs =kmacro-step-edit-macro= that allows you to view
commands of the last keyboard macro, one by one at a time, like a
debugger. When you enter this mode, you have a set of predefined
commands to apply on each command. Press *?* for a list of available
interactive commands and play with it.

**** Tips for using macro effectively
:PROPERTIES:
:ID:       47512938-6e58-4350-829e-e9c5f137195d
:END:

- Find a pattern: after going through all the exercises, you can see
  that a successful macro is a macro that is repeatable, when a
  certain condition is met. Basically, for text transformation, you
  need to create a loop, with proper initialization and end
  condition. If you data does not have a pattern, try to organize it
  in a repeatable way. As you can see in the exercises, data are laid
  out in a way that macro can be repeatable naturally: each line is an
  iteration.
- You can also use a macro for almost anything unrelated to text in
  Emacs. For example, you can create a macro to run =find-file= and to
  go to =~/Downloads=.
- Use registers: As you see in the exercises, macro is a fine way to
  store information. You can use registers as a temporary information
  holder and organize those information into an arbitrary structure
  later.
- Do it slowly and think before you do: Don't rush yourself. Do it
  slowly enough that you are sure when you press some keys and execute
  some commands, it is correct.
- Break large macro into smaller macros.

**** Version Control
:PROPERTIES:
:ID:       112710a7-779a-434c-ad23-e6a9a27aae82
:END:
This section is taken directly from [[http://www.gnu.org/software/emacs/tour/][GNU Emacs Tour]], with
improvements.

Emacs helps you manipulate and edit files stored in version
control. Emacs supports CVS, Subversion, bzr, git, hg, and other
systems, but it offers a uniform interface, called VC, regardless of
the version control system you are using. The benefit of a unified
interface is that even if you aren't familiar with some version
control system (VCS), you can still work with that VCS quickly,
without the burden of learning all the little details of a particular
VCS.

Emacs automatically detects when a file you're editing is under
version control, and displays something like this in the mode line:
CVS-1.14 to indicate the version control system in use, and the
current version.

=M-x vc-next-action= or *C-x v v* commits the current file (prompting you
for a log message) if you've modified it. (Under version control
systems that require locking, this command also acquires a lock for
you.)

VC provides other commands for version control-related tasks:

| Key       | Binding                                                                    |
|-----------+----------------------------------------------------------------------------|
| =C-x v == | *Command*: =vc-diff=                                                       |
|           | Displays a diff showing the changes you've made to the current files.      |
|-----------+----------------------------------------------------------------------------|
| =C-x v ~= | *Commmand*: =vc-revision-other-window=                                     |
|           | Prompts you for a version number and shows you that version of the current |
|           | file in another window.                                                    |
|-----------+----------------------------------------------------------------------------|
| =C-x v g= | *Command*: =vc-annotate=                                                   |
|           | Displays an annotated version of the file showing, for each line,          |
|           | the commit where that line was last changed and by whom. On any            |
|           | line you can press =l= to view the log message for that commit or =d=      |
|           | to view the associated diff.                                               |
|-----------+----------------------------------------------------------------------------|
| =C-x v l= | *Command*: =vc-print-log=                                                  |
|           | Displays a log of previous changes to the file. When point is              |
|           | on a particular log entry, you can press d to view the diff                |
|           | associated with that change or f to view that version of the file.         |
|-----------+----------------------------------------------------------------------------|
| =C-x v u= | *Command*: =vc-revert=                                                              |
|           | Revert working copies of the selected fileset to their repository          |
|           | contents. This asks for confirmation if the buffer contents are not        |
|           | identical to the working revision (except for keyword expansion).          |
|-----------+----------------------------------------------------------------------------|

You can list more operations with *C-x v C-h*.

If you use git, a more specialized package exists dedicated to Git
only: [[https://github.com/magit/magit][Magit]] offers much better features than the general interface
that Emacs provides, except for some features, such as *C-x v =*, *C-x
v ~* and *C-x v u* .

The prefix key bindings for all VC related commands are *C-x v*. The
above are just a few commands that I found most useful and used
frequently, even when I use [[https://github.com/magit/magit][Magit]].

*_Exercise_*:
Let's practice this nice Emacs feature.

- First, download a random Git repository.
- Open any file in the repository.
- Edit that file and save. Do it in various places, so we have many
  hunks.
- *C-x v =* to know precise what changes you made.
- *C-x v g* to view who changes what line on what commit.
- *C-x v ~*, select a commit. After selecting, the version of that
  revision will be displayed in another buffer.
- *C-x v u* to revert the buffer back to its original state, after you
  done playing with it.
- Rinse and repeat until it becomes part of your workflow.

**** Shell
:PROPERTIES:
:ID:       bb3e0977-97b2-450a-9c60-1b80b23280a9
:END:
In Emacs, you have 3 types of shell commands: =shell=, =term= and
=eshell=.

I will just quote a very good answer on StackExchange:

#+BEGIN_QUOTE
[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Shell-Mode.html][shell]] is the oldest of these 3 choices. It uses Emacs's comint-mode to
run a subshell (e.g. bash). In this mode, you're using Emacs to edit a
command line. The subprocess doesn't see any input until you press
Enter. Emacs is acting like a dumb terminal. It does support color
codes, but not things like moving the cursor around, so you can't run
curses-based applications.

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Term-Mode.html][term]] is a terminal emulator written in Emacs Lisp. In this mode, the
keys you press are sent directly to the subprocess; you're using
whatever line editing capabilities the shell presents, not Emacs's. It
also allows you to run programs that use advanced terminal
capabilities like cursor movement (e.g. you could run nano or less
inside Emacs).

[[https://www.gnu.org/software/emacs/manual/html_node/eshell/index.html][eshell]] is a shell implemented directly in Emacs Lisp. You're not
running bash or any other shell as a subprocess. As a result, the
syntax is not quite the same as bash or sh. It allows things like
redirecting the output of a process directly to an Emacs buffer (try
echo hello >#<buffer results>).
#+END_QUOTE

[[http://unix.stackexchange.com/questions/104325/what-is-the-difference-between-shell-eshell-and-term-in-emacs][What is the difference between shell, eshell, and term in Emacs?]]

I suggest you to use eshell, since you can use any Emacs commands
within Eshell as well. However, in Eshell, to send an interrupt
signal, instead of =Ctrl+C=, you need to press twice: =Ctrl+C
Ctrl+C=.
*** Demo: Browsing the kernel source tree
:PROPERTIES:
:ID:       879d6e18-4162-43f6-b5e8-39fa5b5266c7
:END:
You can enjoy exploring the kernel source tree by following these steps:

- Clone the kernel source: =git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git ~/linux=
- *C-x d* and navigate to =~/linux=, then press *Enter*.

  [[https://tuhdo.github.io/static/linux-dir.gif]]

  Then, turn on ggtags: =M-x ggtags-mode= .

- Emacs has a file explorer, as you've seen above, called =Dired=,
  short for =(Dir)ectory (Ed)it=.

- Before start browsing the kernel, you need to create a database for
  quick searching. Press =M-x=, type =ggtags-create-tags=. It asks for
  a directory; since you're in the root directory of Linux already,
  press *Enter*; =ggtags= asks whether you use =ctags= (which is
  another tag generating program, works with more languages but has
  less features). Type =no=, press *Enter* and wait for =ggtags= to
  generate the database.

  [[https://tuhdo.github.io/static/ggtags-create-tags.gif]]

- After the tag database is done generating, a message at the bottom of
  your Emacs prints a message =GTAGS generated in ~/linux=. Now you
  can start going anywhere in Linux source tree in an instant instead
  of spending hours to grep!

- Let's find a file in Linux. Every C program, whether large or small
  must have a ~main()~ function, and a file containing the
  function. Let's find out where the ~main()~ of Linux kernel is.

- =M-x=, type =ggtags-find-file=. *C-c M-f* also executes
  =ggtags-find-file=. A prompt ask for a file to find. You can also
  invoke =ggtags-find-file= with =C-c M-f=.

- Enter =main.c= to the prompt and press *Enter*.
- You will see a list of =main.c= files below in various directory:

  [[https://tuhdo.github.io/static/candidates.jpg]]

  You can visit each file by pressing *M-n* (*n* means /next/) to go
  down or *M-p* to  up (*p* means /previous/).

  Press *M-s s*. A prompt appears waiting for something to search; type
  =init/main.c=. As you type, the candidate buffer got highlighted gradually.

- Finally you get into the correct file. This is where Linux
  starts after the bootloader stage.

- Now, you see a lot of names in this file: variable names, function
  names... Now, you want to find where all of these names are defined
  and where they are used. Let's scroll down a bit, either with *Page
  Down* key or scrolling with the mouse or search for it. If you want
  to search, press *C-s* and type =kernel_init= and press *C-s*
  repeatedly. *C-s* is available everywhere in Emacs. *M-s s* is just
  available in *ggtags*. You see a function declaration like this:

  #+begin_src c
    static int kernel_init(void *);
  #+end_src

  This is the whole process of finding the file:

  [[https://tuhdo.github.io/static/ggtags-find-file.gif]]

  You can find definitions or references of a tag easily. Now, let's
  go back to the declaration ~static int kernel_init(void *);~
  again. Move your cursor on =kernel_init=.

  Press *M-.* jumps to its definition. *M-.* again jumps to its
  references, where the function is called. *M-.* again jumps to the
  definition again. Basically, if the current view is definition,
  pressing *M-.* switches to references and vice verse. Usually, you
  will also see a list of candidates similar to the one you saw using
  =ggtags-find-file= above. Use *M-n* or *M-p* to select next/previous
  match.

  If you want to go back to where you were, press *M-** (or
  *M-Shift-8*) brings you back to the previous place where you
  jumped.

  If you want to jump to a C header file, for example:

  #+begin_src c
    #include <linux/kernel.h>
  #+end_src

  Move your cursor onto that line and press *M-.*.

  Again, you can search for candidates using *M-s s*.

  After navigating for a while, you may have jumped to many places. To
  view the history of where you were, press *C-c M-h*:

  [[https://tuhdo.github.io/static/ggtags-view-tag-history.gif]]

  If you want to have a list of all the tags you visited, press *C-c
  M-/*. The different between this command and the above command is
  that, *C-c M-h* stores the places in files you visited, while *C-c
  M-/* stores the tag operations you performed. After press *C-c M-/*,
  if you   select an entry in the result list, it displays the result
  list of   the tag in the selected entry, along with your match
  candidate you selected in the past:

  [[https://tuhdo.github.io/static/ggtags-rerun.gif]]

  If you create, edit or delete a source file in your project, upon
  saving =ggtags= automatically updates the database of your
  project. How convenient!

  That's it for *basic* navigation. Yes, it's just the basic. This is
  just the tip of the iceberg. In Emacs, you have a toolchain called
  [[http://cedet.sourceforge.net/][CEDET]], short for =Collection of Emacs Development Environment
  Tools=, which offers features such as highlighting, project, smart
  jump, context-sensitive completion, symbol references, code
  generation...  And Emacs includes CEDET by default from Emacs
  23.2. CEDET is also a language framework for language writers to
  create such tools within Emacs for their languages, but currently
  the best supported language in CEDET is C/C++.

  =ggtags= solves your navigation need, but does not offer the above
  features.  However, with =ggtags= alone, it's far enough for your
  C/C++ projects, thanks to GNU Global for working nicely on large
  source tree like the Linux kernel.. After all, many people write
  C/C++ source code on a bare minimum editor and waste a lot of time
  doing things manually instead of focusing on their problems.

  After this demo, are you convinced now? If you want to harness the
  power of Emacs even further, you need to learn Emacs
  properly. Finally, close everything you don't need with *C-x k*

* General Settings
** Platform Specific Configuration
*** OS X Desktop
- Left option key is remapped to M-
- M-3 prints a literal # (UK Mac keyboards being weird)
- We use the Arjen Grey theme
- Font is Monaco
*** OS X CLI in <terminal>
- When the Solarized Dark iTerm2 theme is installed, we use the solarized-dark color theme
- Cut/paste are made to write/read from the clipboard (via pbcopy and pbpaste)
- Mouse highlighting works via xTerm capabilities
** Maximum Workspace
#+BEGIN_SRC emacs-lisp
  (if
      (fboundp 'menu-bar-mode)
      (menu-bar-mode -1))

  (if
      (fboundp 'tool-bar-mode)
      (tool-bar-mode -1))

  (if
      (fboundp 'scroll-bar-mode)
      (scroll-bar-mode -1))

  (setq inhibit-startup-message t)
#+END_SRC
** Client/server

Emacs has a [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html#Emacs-Server][client/server]] model for editing. The client is invoked via [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Invoking-emacsclient.html][the
=emacsclient= command]]. More information on configuration is available on the
[[http://www.emacswiki.org/emacs/EmacsClient][EmacsWiki EmacsClient page]].

We make sure the server is running, additionally guarded to check if the version
of Emacs we're using supports the server package:

#+begin_src emacs-lisp
  (when (require 'server nil t)
    (unless (server-running-p)
      (server-start)))
#+end_src

** Custom Settings
#+BEGIN_SRC emacs-lisp
  (setq custom-file
        (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC
** Load Secrets
#+begin_src emacs-lisp
(load "~/.emacs.d/.secrets")
#+end_src
** Elisp Enhancement
#+BEGIN_SRC emacs-lisp
  (require 'cl)
  (use-package dash
    :config (eval-after-load "dash" '(dash-enable-font-lock)))
  (use-package s)
  (use-package f)
  (use-package diminish)
  (use-package wgrep)
  (use-package scratch)
#+END_SRC
* Package Initialization
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-archives nil)
  (setq package-archives
        '(
          ("org"       . "https://orgmode.org/elpa/")
          ("gnu"       . "http://elpa.gnu.org/packages/")
          ("melpa"     . "http://melpa.org/packages/")
          ("marmalade" . "http://marmalade-repo.org/packages/")))

  (package-initialize)
  (unless (and (file-exists-p "~/.emacs.d/elpa/archives/gnu")
               (file-exists-p "~/.emacs.d/elpa/archives/melpa")
               (file-exists-p "~/.emacs.d/elpa/archives/melpa-stable")
               (file-exists-p "~/.emacs.d/elpa/archives/marmalade")
               )
    (package-refresh-contents))

  ;; use-package
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
  (require 'use-package)
#+END_SRC
* Appearance
** Syntax Highlighting
#+BEGIN_SRC emacs-lisp
  (setq font-lock-maximum-decoration t
        color-theme-is-global t
        truncate-partial-width-windows nil)
#+END_SRC
** Scratch Buffer
#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message (concat ";; One Brick A Day, " user-login-name " - Emacs ♥ you!\n\n"))
#+END_SRC
** Arjen Grey Theme
#+BEGIN_SRC emacs-lisp
  (use-package arjen-grey-theme
    :config
    (when (display-graphic-p)
      (load-theme 'arjen-grey t)))
#+END_SRC
** Fonts

For Syntax Highlighting
#+begin_src emacs-lisp
(global-font-lock-mode 1)
#+end_src
#+BEGIN_SRC emacs-lisp
  (if (or (eq system-type 'darwin)(eq system-type 'gnu/linux) )
  ;    (set-face-attribute 'default nil :font "Consolas-14")
  ;    (set-face-attribute 'default nil :font "Inconsolata-14")
       (set-face-attribute 'default nil :font "Monaco-15" :weight 'bold)
  ;    (set-face-attribute 'default nil :font "Hack-16")
  ;    (set-face-attribute 'default nil :font "DejaVu Sans Mono-16")
    (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 110))

  ;; set italic font for italic face, since Emacs does not set italic
  ;; face automatically
  (set-face-attribute 'italic nil
                      :family "Hack-Italic")
#+END_SRC
** All The Icons
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
  (use-package all-the-icons-dired)
  (use-package pretty-mode)
#+END_SRC
** Cursor

On modern operating systems, a vertical bar is used as a cursor:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq-default cursor-type 'box))
#+end_src

Make the cursor blink (interestingly in Emacs 24.4+ the [[https://lists.gnu.org/archive/html/emacs-diffs/2013-07/msg00208.html][cursor automatically
stops blinking after a period to conserve CPU]]).

Make the cursor blink every second:

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (setq blink-cursor-interval 1.0)
    (blink-cursor-mode 1))
#+end_src

** Typing

Show the modifier combinations I just typed almost immediately:

#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+end_src

Don't make me type =yes= or =no= to boolean interface questions:

#+begin_src emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

** Bells

Don't make a sound when [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Beeping.html][ringing a bell]] - flash a visual bell instead:

#+begin_src emacs-lisp
  (setq visible-bell t)
#+end_src

Override the =ring-bell-function= to conditionally ring the bell only when it's
not a valid quit case like hitting =esc= or =C-g=. Generally this means the bell
will only ring when there's actually an error raised somehow:

#+begin_src emacs-lisp
  (setq ring-bell-function
        (lambda ()
          "Only rings the bell if it's not a valid quit case, e.g
  keyboard-quit"
          (unless (memq this-command
                        '(isearch-abort abort-recursive-edit exit-minibuffer keyboard-quit))
            (ding))))
#+end_src

** Buffer naming

By default Emacs resolves conflicting buffer names by appending a number to
them. For instance, if I open =~/src/thing/init.el= and
=~/src/other-thing/init.el= they'll be named =init.el= and =init.el<2>=
respectively.

We can use [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][Uniquify]] library to name them =thing/init.el= and
=other-thing/init.el=, which is much easier to make sense of.

#+begin_src emacs-lisp
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+end_src
** Frame Title Format
#+BEGIN_SRC emacs-lisp
  (when window-system
    (setq frame-title-format '(buffer-file-name "%f" ("%b")))
    (tooltip-mode -1)
    (blink-cursor-mode -1)
    )
#+END_SRC

** Clipboard management

Make sure that [[http://pragmaticemacs.com/emacs/add-the-system-clipboard-to-the-emacs-kill-ring/][out-of-Emacs clipboard gets into the kill ring]]:

#+begin_src emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+end_src
** Highlight Current Line
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 0)
#+END_SRC
** Highlight Numbers
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
:config
(add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC
** Highlight Symbol
#+BEGIN_SRC emacs-lisp
    (use-package highlight-symbol
    :config

    (require 'highlight-symbol)
    (highlight-symbol-nav-mode)
    (add-hook 'prog-mode-hook
              (lambda() (highlight-symbol-mode)))
    (add-hook 'org-mode-hook (lambda () (highlight-symbol-mode)))
  (setq highlight-symbol-idle-delay 0.2
        highlight-symbol-on-navigation-p t)

  (global-set-key [(control shift mouse-1)]
                  (lambda (event)
                    (interactive "e")
                    (goto-char (posn-point (event-start event)))
                    (highlight-symbol-at-point)))

  (global-set-key (kbd "M-n") 'highlight-symbol-next)
  (global-set-key (kbd "M-p") 'highlight-symbol-prev))
#+END_SRC
** Mode Line
#+begin_src emacs-lisp
  (use-package mode-icons
    :ensure t
    :config
    (mode-icons-mode t)
  )
#+end_src

#+begin_src emacs-lisp
      (use-package powerline
        :ensure t
        :config
        (defvar mode-line-height 30 "A little bit taller, a little bit baller.")

        (defvar mode-line-bar          (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#909fab" nil)))
        (defvar mode-line-eldoc-bar    (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#B3EF00" nil)))
        (defvar mode-line-inactive-bar (eval-when-compile (pl/percent-xpm mode-line-height 100 0 100 0 3 "#9091AB" nil)))

        ;; Custom faces
        (defface mode-line-is-modified nil
          "Face for mode-line modified symbol")

        (defface mode-line-2 nil
          "The alternate color for mode-line text.")

        (defface mode-line-highlight nil
          "Face for bright segments of the mode-line.")

        (defface mode-line-count-face nil
          "Face for anzu/evil-substitute/evil-search number-of-matches display.")

        ;; Git/VCS segment faces
        (defface mode-line-vcs-info '((t (:inherit warning)))
          "")
        (defface mode-line-vcs-warning '((t (:inherit warning)))
          "")

        ;; Flycheck segment faces
        (defface doom-flycheck-error '((t (:inherit error)))
          "Face for flycheck error feedback in the modeline.")
        (defface doom-flycheck-warning '((t (:inherit warning)))
          "Face for flycheck warning feedback in the modeline.")


        (defun doom-ml-flycheck-count (state)
          "Return flycheck information for the given error type STATE."
          (when (flycheck-has-current-errors-p state)
            (if (eq 'running flycheck-last-status-change)
                "?"
              (cdr-safe (assq state (flycheck-count-errors flycheck-current-errors))))))

        (defun doom-fix-unicode (font &rest chars)
          "Display certain unicode characters in a specific font.
      e.g. (doom-fix-unicode \"DejaVu Sans\" ?⚠ ?★ ?λ)"
          (declare (indent 1))
          (mapc (lambda (x) (set-fontset-font
                        t (cons x x)
                        (cond ((fontp font)
                               font)
                              ((listp font)
                               (font-spec :family (car font) :size (nth 1 font)))
                              ((stringp font)
                               (font-spec :family font))
                              (t (error "FONT is an invalid type: %s" font)))))
                chars))

        ;; Make certain unicode glyphs bigger for the mode-line.
        ;; FIXME Replace with all-the-icons?
        (doom-fix-unicode '("DejaVu Sans Mono" 15) ?✱) ;; modified symbol
        (let ((font "DejaVu Sans Mono for Powerline")) ;;
          (doom-fix-unicode (list font 12) ?)  ;; git symbol
          (doom-fix-unicode (list font 16) ?∄)  ;; non-existent-file symbol
          (doom-fix-unicode (list font 15) ?)) ;; read-only symbol

        ;; So the mode-line can keep track of "the current window"
        (defvar mode-line-selected-window nil)
        (defun doom|set-selected-window (&rest _)
          (let ((window (frame-selected-window)))
            (when (and (windowp window)
                       (not (minibuffer-window-active-p window)))
              (setq mode-line-selected-window window))))
        (add-hook 'window-configuration-change-hook #'doom|set-selected-window)
        (add-hook 'focus-in-hook #'doom|set-selected-window)
        (advice-add 'select-window :after 'doom|set-selected-window)
        (advice-add 'select-frame  :after 'doom|set-selected-window)

        (defun doom/project-root (&optional strict-p)
          "Get the path to the root of your project."
          (let (projectile-require-project-root strict-p)
            (projectile-project-root)))

        (defun *buffer-path ()
          "Displays the buffer's full path relative to the project root (includes the
      project root). Excludes the file basename. See `*buffer-name' for that."
          (when buffer-file-name
            (propertize
             (f-dirname
              (let ((buffer-path (file-relative-name buffer-file-name (doom/project-root)))
                    (max-length (truncate (/ (window-body-width) 1.75))))
                (concat (projectile-project-name) "/"
                        (if (> (length buffer-path) max-length)
                            (let ((path (reverse (split-string buffer-path "/" t)))
                                  (output ""))
                              (when (and path (equal "" (car path)))
                                (setq path (cdr path)))
                              (while (and path (<= (length output) (- max-length 4)))
                                (setq output (concat (car path) "/" output))
                                (setq path (cdr path)))
                              (when path
                                (setq output (concat "../" output)))
                              (when (string-suffix-p "/" output)
                                (setq output (substring output 0 -1)))
                              output)
                          buffer-path))))
             'face (if active 'mode-line-2))))

        (defun *buffer-name ()
          "The buffer's base name or id."
          ;; FIXME Don't show uniquify tags
          (s-trim-left (format-mode-line "%b")))

        (defun *buffer-pwd ()
          "Displays `default-directory', for special buffers like the scratch buffer."
          (propertize
           (concat "[" (abbreviate-file-name default-directory) "]")
           'face 'mode-line-2))

        (defun *buffer-state ()
          "Displays symbols representing the buffer's state (non-existent/modified/read-only)"
          (when buffer-file-name
            (propertize
             (concat (if (not (file-exists-p buffer-file-name))
                         "∄"
                       (if (buffer-modified-p) "✱"))
                     (if buffer-read-only ""))
             'face 'mode-line-is-modified)))

        (defun *buffer-encoding-abbrev ()
          "The line ending convention used in the buffer."
          (if (memq buffer-file-coding-system '(utf-8 utf-8-unix))
              ""
            (symbol-name buffer-file-coding-system)))

        (defun *major-mode ()
          "The major mode, including process, environment and text-scale info."
          (concat (format-mode-line mode-name)
                  (if (stringp mode-line-process) mode-line-process)
                  (and (featurep 'face-remap)
                       (/= text-scale-mode-amount 0)
                       (format " (%+d)" text-scale-mode-amount))))

        (defun *vc ()
          "Displays the current branch, colored based on its state."
          (when vc-mode
            (let ((backend (concat " " (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))
                  (face (let ((state (vc-state buffer-file-name)))
                          (cond ((memq state '(edited added))
                                 'mode-line-vcs-info)
                                ((memq state '(removed needs-merge needs-update conflict removed unregistered))
                                 'mode-line-vcs-warning)))))
              (if active
                  (propertize backend 'face face)
                backend))))

        (defvar-local doom--flycheck-err-cache nil "")
        (defvar-local doom--flycheck-cache nil "")
        (defun *flycheck ()
          "Persistent and cached flycheck indicators in the mode-line."
          (when (and (featurep 'flycheck)
                     flycheck-mode
                     (or flycheck-current-errors
                         (eq 'running flycheck-last-status-change)))
            (or (and (or (eq doom--flycheck-err-cache doom--flycheck-cache)
                         (memq flycheck-last-status-change '(running not-checked)))
                     doom--flycheck-cache)
                (and (setq doom--flycheck-err-cache flycheck-current-errors)
                     (setq doom--flycheck-cache
                           (let ((fe (doom-ml-flycheck-count 'error))
                                 (fw (doom-ml-flycheck-count 'warning)))
                             (concat
                              (if fe (propertize (format " •%d " fe)
                                                 'face (if active
                                                           'doom-flycheck-error
                                                         'mode-line)))
                              (if fw (propertize (format " •%d " fw)
                                                 'face (if active
                                                           'doom-flycheck-warning
                                                         'mode-line))))))))))

        (defun *buffer-position ()
          "A more vim-like buffer position."
          (let ((start (window-start))
                (end (window-end))
                (pend (point-max)))
            (if (and (= start 1)
                     (= end pend))
                ":All"
              (cond ((= start 1) ":Top")
                    ((= end pend) ":Bot")
                    (t (format ":%d%%%%" (/ end 0.01 pend)))))))

        (defun my-mode-line (&optional id)
          `(:eval
            (let* ((active (eq (selected-window) mode-line-selected-window))
                   (lhs (list (propertize " " 'display (if active mode-line-bar mode-line-inactive-bar))
                              (*flycheck)
                              " "
                              (*buffer-path)
                              (*buffer-name)
                              " "
                              (*buffer-state)
                              ,(if (eq id 'scratch) '(*buffer-pwd))))
                   (rhs (list (*buffer-encoding-abbrev) "  "
                              (*vc)
    ;;                          " "
    ;;                          (when persp-curr persp-modestring)
                              " " (*major-mode) "  "
                              (propertize
                               (concat "(%l,%c) " (*buffer-position))
                               'face (if active 'mode-line-2))))
                   (middle (propertize
                            " " 'display `((space :align-to (- (+ right right-fringe right-margin)
                                                               ,(1+ (string-width (format-mode-line rhs)))))))))
              (list lhs middle rhs)))))

    (setq-default mode-line-format (my-mode-line))

#+end_src
* Third Party Packages
** Atomic Chrome
#+begin_src emacs-lisp
  (use-package atomic-chrome
    :config
    (require 'atomic-chrome)
    (atomic-chrome-start-server)
    (setq atomic-chrome-buffer-open-style 'full))
#+end_src
** Whitespace Mode
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :bind ("C-c T w" . whitespace-mode)
    :init
    (setq whitespace-line-column nil
          whitespace-display-mappings '((space-mark 32 [183] [46])
                                        (newline-mark 10 [9166 10])
                                        (tab-mark 9 [9654 9] [92 9])))
    :config
    (set-face-attribute 'whitespace-space       nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-newline     nil :foreground "#666666" :background nil)
    (set-face-attribute 'whitespace-indentation nil :foreground "#666666" :background nil)
    :diminish whitespace-mode)
#+END_SRC
** Try
#+begin_src emacs-lisp
(use-package try)
#+end_src
** Workgroups2
- create your workspace in emacs
- saves all your opened buffers, their locations and sizes on disk to restore later
#+begin_src emacs-lisp
  (use-package workgroups2
    :config
    (require 'workgroups2)

    ;; Change prefix key (before activating WG)
    (setq wg-prefix-key (kbd "C-c z"))
    ;; Change workgroups session file
    (setq wg-session-file "~/.emacs.d/.emacs_workgroups")
    ;; What to do on Emacs exit / workgroups-mode exit?
    (setq wg-emacs-exit-save-behavior           'save)
    (setq wg-workgroups-mode-exit-save-behavior 'save)

    ;; Mode Line Changes
    ;; Display workgroups in Mode Line?
    (setq wg-mode-line-display-on t)
    (setq wg-flag-modified t)
    (setq wg-mode-line-decor-left-brace "["
          wg-mode-line-decor-right-brace "]"
          wg-mode-line-decor-divider ":")
    (workgroups-mode 1))
#+end_src
** Hippie Expand                                                     :Drill:
hippe-expand is a better version of dabbrev-expand while dabbrev-expand searches for words you already types in current buffers and other buffers,
hippie-expand includes more sources such as filenames, kill ring…
#+begin_src emacs-lisp
(global-set-key (kbd "M-/") 'hippie-expand) ;; replace dabbrev-expand
(setq
 hippie-expand-try-functions-list
 '(try-expand-dabbrev ;; Try to expand word "dynamically", searching the current buffer.
   try-expand-dabbrev-all-buffers ;; Try to expand word "dynamically", searching all other buffers.
   try-expand-dabbrev-from-kill ;; Try to expand word "dynamically", searching the kill ring.
   try-complete-file-name-partially ;; Try to complete text as a file name, as many characters as unique.
   try-complete-file-name ;; Try to complete text as a file name.
   try-expand-all-abbrevs ;; Try to expand word before point according to all abbrev tables.
   try-expand-list ;; Try to complete the current line to an entire line in the buffer.
   try-expand-line ;; Try to complete the current line to an entire line in the buffer.
   try-complete-lisp-symbol-partially ;; Try to complete as an Emacs Lisp symbol, as many characters as unique.
   try-complete-lisp-symbol) ;; Try to complete word as an Emacs Lisp symbol.
 )
#+end_src
** Auto Complete
#+begin_src emacs-lisp
  ;; (use-package auto-complete
  ;; :config
  ;; (require 'auto-complete-config)
  ;; (ac-config-default)
  ;; (setq ac-show-menu-immediately-on-auto-complete t))
#+end_src
Company Mode
#+begin_src emacs-lisp
(use-package company
  :ensure t
  :init
  (setq company-dabbrev-ignore-case t
        company-show-numbers t)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode)
  :bind ("C-:" . company-complete)  ; In case I don't want to wait
  :diminish company-mode)
#+end_src

Quick Documentation
#+begin_src emacs-lisp
(use-package company-quickhelp
  :ensure t
  :config
  (company-quickhelp-mode 1))
#+end_src
** Expand Region
#+begin_src emacs-lisp
(use-package expand-region
:config
(require 'expand-region)
(global-set-key (kbd "M-m") 'er/expand-region))
#+end_src
** Bookmarks Manager
#+begin_src emacs-lisp
(use-package bm
  :bind (("C-c =" . bm-toggle)
         ("C-c [" . bm-previous)
         ("C-c ]" . bm-next)))
#+end_src
** Windows Management
#+begin_src emacs-lisp
(use-package ace-window
:init
(progn
(setq aw-scope 'frame)
(global-set-key (kbd "C-x O") 'other-frame)
  (setq aw-keys '(?a ?s ?d ?f ?j ?k ?l ?o))
  (global-set-key [remap other-window] 'ace-window)
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 3.0)))))
  ))

(use-package ace-jump-mode
  :config
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode))
#+end_src
** Indent Whole Buffer
#+begin_src emacs-lisp
(defun iwb ()
  "indent whole buffer"
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))

(global-set-key (kbd "C-c n") 'iwb)
#+end_src
** Command Log Mode
#+begin_src emacs-lisp
(use-package command-log-mode)
#+end_src
** Zygospore

zygospore lets you revert C-x 1 (delete-other-window) by pressing C-x 1 again
[[https://github.com/LouisKottmann/zygospore.el/raw/master/demo.gif]]
#+begin_src emacs-lisp
(use-package zygospore
  :bind (("C-x 1" . zygospore-toggle-delete-other-windows)
         ("RET" .   newline-and-indent)))
#+end_src

** Origami
#+begin_src emacs-lisp
(use-package origami
:ensure t
:config
(require 'origami)
(add-hook 'prog-mode-hook 'origami-mode)
(define-key origami-mode-map (kbd "C-c f") 'origami-recursively-toggle-node)
(define-key origami-mode-map (kbd "C-c F") 'origami-toggle-all-nodes))
#+end_src
** Duplicate Thing
#+begin_src emacs-lisp
(use-package duplicate-thing
:ensure t
:config
(require 'duplicate-thing)
(global-set-key (kbd "M-c") 'duplicate-thing))
#+end_src
** Smartparens
#+begin_src emacs-lisp
(use-package smartparens-config
:ensure smartparens
:config
(progn
(show-smartparens-global-mode t)))

(add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
;(add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
(bind-keys
 :map smartparens-mode-map
 ("C-M-a" . sp-beginning-of-sexp)
 ("C-M-e" . sp-end-of-sexp)

 ("C-<down>" . sp-down-sexp)
 ("C-<up>"   . sp-up-sexp)
 ("M-<down>" . sp-backward-down-sexp)
 ("M-<up>"   . sp-backward-up-sexp)

 ("C-M-f" . sp-forward-sexp)
 ("C-M-b" . sp-backward-sexp)

 ("C-M-n" . sp-next-sexp)
 ("C-M-p" . sp-previous-sexp)

 ("C-S-f" . sp-forward-symbol)
 ("C-S-b" . sp-backward-symbol)

 ("C-<right>" . sp-forward-slurp-sexp)
 ("M-<right>" . sp-forward-barf-sexp)
 ("C-<left>"  . sp-backward-slurp-sexp)
 ("M-<left>"  . sp-backward-barf-sexp)

 ("C-M-t" . sp-transpose-sexp)
 ("C-M-k" . sp-kill-sexp)
 ("C-k"   . sp-kill-hybrid-sexp)
 ("M-k"   . sp-backward-kill-sexp)
 ("C-M-w" . sp-copy-sexp)
 ("C-M-d" . delete-sexp)

 ("M-<backspace>" . backward-kill-word)
 ("C-<backspace>" . sp-backward-kill-word)
 ([remap sp-backward-kill-word] . backward-kill-word)

 ("M-[" . sp-backward-unwrap-sexp)
 ("M-]" . sp-unwrap-sexp)

 ("C-x C-t" . sp-transpose-hybrid-sexp)

 ("C-c ("  . wrap-with-parens)
 ("C-c ["  . wrap-with-brackets)
 ("C-c {"  . wrap-with-braces)
 ("C-c M-'"  . wrap-with-single-quotes)
 ("C-c \"" . wrap-with-double-quotes)
 ("C-c _"  . wrap-with-underscores)
 ("C-c `"  . wrap-with-back-quotes))
#+end_src
** Which Mode
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :defer 10
    :diminish which-key-mode
    :config

    ;; Replacements for how KEY is replaced when which-key displays
    ;;   KEY → FUNCTION
    ;; Eg: After "C-c", display "right → winner-redo" as "▶ → winner-redo"
    (setq which-key-key-replacement-alist
          '(("<\\([[:alnum:]-]+\\)>" . "\\1")
            ("left"                  . "◀")
            ("right"                 . "▶")
            ("up"                    . "▲")
            ("down"                  . "▼")
            ("delete"                . "DEL") ; delete key
            ("\\`DEL\\'"             . "BS") ; backspace key
            ("next"                  . "PgDn")
            ("prior"                 . "PgUp"))

          ;; List of "special" keys for which a KEY is displayed as just
          ;; K but with "inverted video" face... not sure I like this.
          which-key-special-keys '("RET" "DEL" ; delete key
                                   "ESC" "BS" ; backspace key
                                   "SPC" "TAB")

          ;; Replacements for how part or whole of FUNCTION is replaced:
          which-key-description-replacement-alist
          '(("Prefix Command" . "prefix")
            ("\\`calc-"       . "") ; Hide "calc-" prefixes when listing M-x calc keys
            ("\\`projectile-" . "𝓟/")
            ("\\`org-babel-"  . "ob/"))

          ;; Underlines commands to emphasize some functions:
          which-key-highlighted-command-list
          '("\\(rectangle-\\)\\|\\(-rectangle\\)"
            "\\`org-"))

    ;; Change what string to display for a given *complete* key binding
    ;; Eg: After "C-x", display "8 → +unicode" instead of "8 → +prefix"
    (which-key-add-key-based-replacements
      "C-x 8"   "unicode"
      "C-c T"   "toggles-"
      "C-c p s" "projectile-search"
      "C-c p 4" "projectile-other-buffer-"
      "C-x a"   "abbrev/expand"
      "C-x r"   "rect/reg"
      "C-c /"   "engine-mode-map"
      "C-c C-v" "org-babel")

    (which-key-mode 1))
#+end_src
** Undo Tree

undo-tree allows you to visual the whole history of your editing in a tree. 
It also provides regular undo/redo behaviours in other editors. 
undo-tree can even provide a diff between two different states. 
Highly recommended.

[[https://camo.githubusercontent.com/85240e7df44ee70d29d68187e15d7a8a37291c4a/68747470733a2f2f747568646f2e6769746875622e696f2f7374617469632f70617274332f756e646f2d747265652e6a7067]]

#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :diminish undo-tree-mode
    :init
    (global-undo-tree-mode 1)
    :config
    (defalias 'redo 'undo-tree-redo)
    (require 'undo-tree)
    :bind (("C-z" . undo)
           ("C-S-z" . redo)))
#+end_src

** Yasnippet
#+begin_src emacs-lisp
  (use-package yasnippet
  :ensure t
  :config
  (require 'yasnippet)
  (yas-global-mode 1)
  (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))
#+end_src
** Vimish Fold
#+begin_src emacs-lisp
(use-package vimish-fold)
(require 'vimish-fold)
(vimish-fold-global-mode -1)
;; this registers a region for future folding/unfolding
(global-set-key (kbd "C-c v") #'vimish-fold)
;; this unregisters the region under point from folding/unfolding
(global-set-key (kbd "C-c d") #'vimish-fold-delete)
;; this is the actual fold/unfold command
(global-set-key (kbd "C-c t") #'vimish-fold-toggle)
#+end_src
** Multiple Cursors
#+begin_src emacs-lisp 
  (use-package multiple-cursors
    :config
    (require 'multiple-cursors)
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "M-+") 'mc/mark-next-like-this)
    (global-set-key (kbd "M--") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c M-+") 'mc/mark-all-like-this))
#+end_src

** Magit
#+begin_src emacs-lisp
(use-package magit
  :commands magit-status magit-blame
  :init
  (defadvice magit-status (around magit-fullscreen activate)
    (window-configuration-to-register :magit-fullscreen)
    ad-do-it
    (delete-other-windows))
  :config
  (setq vc-follow-symlinks nil
        magit-push-always-verify nil
        magit-restore-window-configuration t)
  :bind ("C-x g" . magit-status))
#+end_src
** Helm

_Author_: Tamas Patrovic, rubikitch, thierry volpiatto [[thierry.volpaitt@gmail.com]]
_Homepages_: [[https://github.com/emacs-helm/helm]]

_Features_: 
1. incremental completion
2. selection narrowing framework for emacs

_Installation_: I am going to use =use-package=

_Usage_:
1. type parts of the candidate you are looking for. they are called patterns. =M-a= to select all.
2. you can mark candidates with =C-SPC=; this is useful when you need to perform an action on many candidates of your choice
3. you can insert marked candidates into the current buffer with =C-c C-i=. This is useful when you have narrowed to a list of candidates, i.e. files, and then you want to save such candidates
4. if you find the current horizontal Helm window is small, you can always switch it to a vertical window with =C-t=. Running =C-t= again returns the Helm window back to horizontal and so on.

When you execute a Helm command, you enter a Helm session. A Helm session is a dedicated state to working with Helm features.
While in a Helm Session, a dedicated Helm buffer is always opened. When you quit a Helm Session, a Helm buffer is closed.

In Helm you basically need to remember these 3 Commands:
1. Access the action menu with =TAB=. An action is a command to run on marked candidates (one or more) and quits the current Helm Session. An action menu is a text-based menu that lists actions you can take.
For example,  
  - =Find File= (Open File)
  - =Find File in Dired=
  - =Grep File=
2. =C-z= executes =helm-execute-persistent-action=. A persistent action is an action that you use in a Helm Session that does not quit the session.
3. In some helm sessions, such as =helm-find-files= or =helm-mini= you can select more than one candidates and execute actions on them, such as =grep= or =open= 

#+begin_src emacs-lisp
  (use-package helm
  :diminish helm-mode
  :init
  (setq helm-idle-delay 0.0
        helm-input-idle-delay 0.01
        helm-yas-display-key-on-candidate t
        helm-quick-update t
        helm-M-x-requires-pattern nil
        helm-ff-skip-boring-files t)
  (helm-mode)
  :ensure t)

  (require 'helm)
  (require 'helm-config)

  ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs
  ;; Change to "C-c h"
  (global-set-key (kbd "C-c h") 'helm-command-prefix)
  (global-unset-key (kbd "C-x c"))
  (global-set-key (kbd "M-x") #'helm-M-x)
  (global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
  (global-set-key (kbd "C-x C-f") #'helm-find-files)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-c h o") 'helm-occur)
  ; rebind tab to run persistent action
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ; make TAB work in terminal
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ; list actions using C-z
  (define-key helm-map (kbd "C-z")  'helm-select-action)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (setq helm-split-window-in-side-p       t ; open helm buffer inside current window, not occupy whole other window
    helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
    helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
    helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
    helm-ff-file-name-history-use-recentf t
    helm-echo-input-in-header-line t)

  (defun spacemacs//helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))
                       `(:background ,bg-color :foreground ,bg-color)))
        (setq-local cursor-type nil))))

  (add-hook 'helm-minibuffer-set-up-hook
            'spacemacs//helm-hide-minibuffer-maybe)

  (setq helm-M-x-fuzzy-match t) ;; optional fuzzy matching for helm-M-x
  (setq helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match    t)
  (setq helm-autoresize-max-height 0)
  (setq helm-autoresize-min-height 20)
  (helm-autoresize-mode 1)
  (helm-mode 1)

  (when (executable-find "ack-grep")
    (setq helm-grep-default-command "ack-grep -Hn --no-group --no-color %e %p %f"
          helm-grep-default-recurse-command "ack-grep -H --no-group --no-color %e %p %f"))
  (setq helm-locate-fuzzy-match t)
  (setq helm-apropos-fuzzy-match t)
#+end_src

helm-descbinds
#+begin_src emacs-lisp
(use-package helm-descbinds
  :defer t
  :bind(
        ("C-h b" . helm-descbinds)
        ("C-h w" . helm-descbinds)))
#+end_src
** Projectile                                                        :Drill:
_Features_:
- jump to a file in project
- jump to a directory in a project
- jump to file in a dir
- jump to a project buffer
- jump to a test in project
- toggle between code and its test
- jump to recently visited files in the project
- switch between projects you have worked on
- kill all project buffers
- replace in project
- multi-occur in project buffers
- grep in project
- regenerate project etags or gtags
- visit project in dired
- run make in a project with a single key chord
- check for dirty repos

Some Helpful Commands
- C-c p s Switch to project
- C-c p f List files in project
- C-c p k Kill all buffers for project

#+begin_src emacs-lisp
(use-package projectile
:config
(require 'projectile)
(projectile-global-mode))
#+end_src
*** Helm Projectile
_Demos_:
1. Select and open multiple files:
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-1.gif]]
_Problem_: when I select multiple files it all opens in separate windows. Instead I want to open them behind the scenes. that means they would be opened in my buffer list.
2. Open a file at point anywhere
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-files-dwim-1.gif]]
  - In the demo the first path is a file that I opened using a command from =M-x=.
  - The second path is a directory that I opened using a key binding.
  - The third path is highlighted in a region and I opened using command history in Helm, so no need to type anything.
3. Copy Files anywhere
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-copy.gif]]
4. Delete Files anywhere
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-file-delete.gif]]
5. Switch between current file and other files with same names but different extensions
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-find-other-file.gif]]
  - First, I select helm-projectile-find-other-file and a list of other files displayed.
  - Then, I marked a few files and press RET to open all.
  - Finally, I use helm-mini to open a list of opened buffers and the files I marked and opened are there.
6. =helm-projectile-switch-project=
[[https://tuhdo.github.io/static/helm-projectile/helm-projectile-switch-project.gif]]
  - Open Dired =C-d=
  - Open Project Root =M-g=
  -  Switch to Eshell =M-e=
  - Grep in projects (C-s; add prefix to C-u to recursive grep): As you type the regexp in the mini buffer, the live grep results will be displayed incrementally.
  - Compile Project =C-d=
  - Remove Project =M-D=
 [[https://tuhdo.github.io/static/helm-projectile/helm-projectile-remove-project.gif]]

_File Management_:
1. =helm-projectile-find-file= =C-c p f=
   Open:
   - find file:
   - find file other window
   - find file other Frame
   - find file in Dired
   - view file
   - Open File Externally
   Move and Rename
   - Rename Files
   - Serial Rename Files
   Copy and Delete
   - Copy Files
   - Delete Files
   Search and Replace
   - Grep Files ;todo;
   - ZGrep Files ;todo;
   - Locate ;todo;
   Virtual Directory Manager
   Buffer Management
   Search in Project
   - helm projectile grep
     [[https://tuhdo.github.io/static/helm-projectile/helm-projectile-grep.gif]]

#+begin_src emacs-lisp
  (use-package helm-projectile)
  (projectile-global-mode)
  (setq projectile-completion-system 'helm)
  (setq projectile-switch-project-action 'helm-projectile)
  (setq projectile-enable-caching t)
  (helm-projectile-on)
#+end_src
** Helm Gtags
#+begin_src emacs-lisp
  (use-package helm-gtags
    :config
    (setq helm-gtags-ignore-case t
          helm-gtags-auto-update t
          helm-gtags-use-input-at-cursor t
          helm-gtags-prefix-key "\C-cg"
          helm-gtags-suggested-key-mapping t)
    (require 'helm-gtags)
    ;; Enable helm-gtags-mode
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "C-M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "C-M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))
#+end_src
** Hydra
#+begin_src emacs-lisp
(use-package hydra)
#+end_src
** Rest Support
#+BEGIN_SRC emacs-lisp
(use-package restclient
    :ensure t)
#+END_SRC
** Beacon Mode
#+begin_src emacs-lisp
  (use-package beacon
    :config
    (beacon-mode 1)
    (setq beacon-color "#000000"))
#+end_src
** Hungry Delete
#+begin_src emacs-lisp
(use-package hungry-delete
  :ensure t
  :config
  (global-hungry-delete-mode))
#+end_src
** Linum Mode
*** Line Numbers
Turn =linum-mode= on/off with =Command-K=. However, I turn this on automatically for programming modes.
#+begin_src emacs-lisp
  (use-package linum
    :init
    (add-hook 'prog-mode-hook 'linum-mode)
    (add-hook 'linum-mode-hook (lambda () (set-face-attribute 'linum nil :height 110)))

    :config
    (defun linum-fringe-toggle ()
      "Toggles the line numbers as well as the fringe."    (interactive)
      (cond (linum-mode (fringe-mode '(0 . 0))
                        (linum-mode -1))
            (t          (fringe-mode '(8 . 0))
                        (linum-mode 1))))

    :bind (("A-C-k"   . linum-mode)
           ("s-C-k"   . linum-mode)
           ("A-C-M-k" . linum-fringe-toggle)
           ("s-C-M-k" . linum-fringe-toggle)))
#+end_src

The Linum-Realtive Mode allows one to see the destination line as a relative distance
#+begin_src emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
    (defun linum-new-mode ()
      "If line numbers aren't displayed, then display them.
       Otherwise, toggle between absolute and relative numbers."
      (interactive)
      (if linum-mode
          (linum-relative-toggle)
        (linum-mode 1)))

    :bind ("C-c k" . linum-new-mode)
          ("C-c K" . linum-new-mode))   ;; For Linux

#+end_src

* Editing
** Encoding System                                                   :Drill:
#+begin_src emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src
** Delete Selection Mode

#+BEGIN_SRC emacs-lisp
(delete-selection-mode)
#+END_SRC
** Newline and Indent
#+begin_src emacs-lisp
(global-set-key (kbd "RET") 'newline-and-indent)
#+end_src
** Highlight Indentation
#+begin_src emacs-lisp
(use-package highlight-indentation)
(require 'highlight-indentation)
(add-hook 'prog-mode-hook 'highlight-indentation-mode)
(add-hook 'prog-mode-hook 'highlight-indentation-current-column-mode)
(set-face-background 'highlight-indentation-face "#616161")
(set-face-background 'highlight-indentation-current-column-face "#607D8B")
#+end_src
** Code Block Folding
#+BEGIN_SRC emacs-lisp
(use-package hideshow
    :ensure t
    :bind (("C->" . my-toggle-hideshow-all)
           ("C-<" . hs-hide-level)
           ("C-;" . hs-toggle-hiding))
    :config
    ;; Hide the comments too when you do a 'hs-hide-all'
    (setq hs-hide-comments nil)
    ;; Set whether isearch opens folded comments, code, or both
    ;; where x is code, comments, t (both), or nil (neither)
    (setq hs-isearch-open 'x)
    ;; Add more here


    (setq hs-set-up-overlay
          (defun my-display-code-line-counts (ov)
            (when (eq 'code (overlay-get ov 'hs))
              (overlay-put ov 'display
                           (propertize
                            (format " ... <%d>"
                                    (count-lines (overlay-start ov)
                                                 (overlay-end ov)))
                            'face 'font-lock-type-face)))))

    (defvar my-hs-hide nil "Current state of hideshow for toggling all.")
         ;;;###autoload
    (defun my-toggle-hideshow-all () "Toggle hideshow all."
           (interactive)
           (setq my-hs-hide (not my-hs-hide))
           (if my-hs-hide
               (hs-hide-all)
             (hs-show-all)))

    (add-hook 'prog-mode-hook (lambda ()
                                (hs-minor-mode 1)
                                ))
    (add-hook 'clojure-mode-hook (lambda ()
                                (hs-minor-mode 1)
                                ))
    )
#+END_SRC
* Key Bindings
** Frequent Files Shortcut
#+BEGIN_SRC emacs-lisp
  ;; main config file
  (global-set-key
   (kbd "\e\ec")
   (lambda()
     (interactive)
     (find-file "~/.emacs.d/README.org")))

  ;; main index file
  (global-set-key
   (kbd "\e\ei")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/index.org")))


  ;; reference for future use
  (global-set-key
   (kbd "\e\er")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/reference.org")))

  ;; tickler.org
  (global-set-key
   (kbd "\e\et")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/tickler.org")))

  ;; someday.org
  (global-set-key
   (kbd "\e\es")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/someday.org")))

  ;; projects.org
  (global-set-key
   (kbd "\e\ep")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/projects.org")))

  ;; waiting.org
  (global-set-key
   (kbd "\e\ew")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/waiting.org")))

  ;; now.org
  (global-set-key
   (kbd "\e\en")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/now.org")))

  ;; links
  (global-set-key
   (kbd "\e\el")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/links.org")))

  ;; finance
  (global-set-key
   (kbd "\e\ef")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/finance.org")))

  ;; appointments meetings
  (global-set-key
   (kbd "\e\eg")
   (lambda()
     (interactive)
     (find-file "~/Dropbox/org/gcal.org")))

  ;; ends here
#+END_SRC
** Kill This Buffer
#+begin_src emacs-lisp
(global-set-key (kbd "C-x k") 'kill-this-buffer)
#+end_src
* Org Mode
** Global Settings

setting org mode for all .org, .org_archive and text files
#+begin_src emacs-lisp
  (add-to-list
   'auto-mode-alist
   '("\\.\\(org\\|org_archive\\|txt\\)$" . org-mode))

  (require 'org)
#+end_src

the four commands =org-store-link=, =org-capture=, =org-agenda=, =org-iswitchb=
should be accessible through global keys.
#+begin_src emacs-lisp
(global-set-key "\C-cb" 'org-iswitchb)
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
#+end_src

Files with the =.org= extension use Org Mode By Default.
To turn on org mode in a file that does not have the extension =.org=,
make the first line of a file look like this:
#+begin_example
MY PROJECTS -*- mode: org; -*-
#+end_example

which will select Org mode for this buffer no matter what the file’s name is.
#+begin_src emacs-lisp
  (setq
   org-directory "~/Dropbox/org"
   org-default-notes-file (concat org-directory "/notes.org")
   org-export-html-postamble nil
   org-hide-leading-stars t
   org-hide-emphasis-markers t
   org-startup-folded (quote overview)
   org-startup-indented t
   )
#+end_src

What does this snippet do?
#+begin_src emacs-lisp
(font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+end_src

** Org Todo Keywords
#+begin_src emacs-lisp
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

  (setq org-log-done 'time)
  (setq org-log-done 'note)

(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)

#+end_src
** Code Block Shortcuts
ref: sacha
#+BEGIN_SRC emacs-lisp
(setq org-structure-template-alist
      '(("s" "#+begin_src ?\n\n#+end_src" "<src lang=\"?\">\n\n</src>")
        ("e" "#+begin_example\n?\n#+end_example" "<example>\n?\n</example>")
        ("q" "#+begin_quote\n?\n#+end_quote" "<quote>\n?\n</quote>")
        ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE" "<verse>\n?\n</verse>")
        ("l" "#+begin_src emacs-lisp\n?\n#+end_src" "<src lang=\"emacs-lisp\">\n?\n</src>")
        ("p" "#+begin_src python\n?\n#+end_src" "<src lang=\"python\">\n?\n</src>")
        ("c" "#+begin_src cpp\n?\n#+end_src" "<src lang=\"cpp\">\n?\n</src>")
        ("L" "#+latex: " "<literal style=\"latex\">?</literal>")
        ("h" "#+begin_html\n?\n#+end_html" "<literal style=\"html\">\n?\n</literal>")
        ("H" "#+html: " "<literal style=\"html\">?</literal>")
        ("a" "#+begin_ascii\n?\n#+end_ascii")
        ("A" "#+ascii: ")
        ("i" "#+index: ?" "#+index: ?")
        ("I" "#+include %file ?" "<include file=%file markup=\"?\">")))
#+END_SRC
** Htmlize RSS
#+begin_src emacs-lisp
(require 'ox-html)
(require 'ox-publish)
(require 'ox-rss)
(use-package htmlize
   :ensure t)

#+end_src
** Org Reveal
#+begin_src emacs-lisp
(use-package ox-reveal)
(setq org-reveal-root "http://cdn.jsdelivr.net/reveal.js/3.0.0/")
(setq org-reveal-mathjax t)
#+end_src
** Org Agenda
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("c" "Simple agenda view" ((agenda "") (alltodo "")))))

  (setq org-agenda-files
        (list "~/Dropbox/org"))

  ;; Do not  dim blocked tasks
  (setq org-agenda-dim-blocked-tasks nil)

  ;; Compact the block agenda view
  (setq org-agenda-compact-blocks t)
#+end_src
** Org AC : Auto Complete Org Mode
#+begin_src emacs-lisp
(use-package org-ac
      :init (progn
              (require 'org-ac)
              (org-ac/config-default)
              ))
#+end_src
** Org Capture
#+begin_src emacs-lisp
  (setq
   org-capture-templates
   '(
     ("a" "Appointment" entry (file  "~/Dropbox/org/gcal.org" )
     "* %?\n%^T")
     ("c" "Capture" entry (file  "~/Dropbox/org/index.org" )
     "* %?\n%U\n%a")
     ("j" "Journal" entry (file+headline "~/Dropbox/org/reference.org" "Journal")
      "* %t\n** Day\n*** What am I Grateful For:\n1. %?\n2. \n3. \n*** What Would Make Today Great:\n1. \n2. \n3. \n*** Daily Affirmations I am:\n1. \n2. \n3. \n\n** Night\n*** 3 Amazing Things Happened Today:\n1. \n2. \n3. \n*** How could I Make Things Better\n1. \n2. \n3. \n" :prepend t)
     ("l" "Link" entry (file "~/Dropbox/org/links.org")
      "* %?%^L %^G \n%U" :prepend t)
     ("t" "Todo" entry (file+headline "~/Dropbox/org/index.org" "Tasks")
      "* TODO [#A] %^{GOAL} %^G\nSCHEDULED: %^{SCHEDULED}T\nDEADLINE: %^{DEADLINE}T\n%a" :prepend t :clock-in t :clock-resume t)
     ("o" "One Things" entry (file+headline "~/Dropbox/org/reference.org" "One Things")
      "* TODO [#A] %^{GOAL} %^G\nSCHEDULED: %^{SCHEDULED}t\nDEADLINE: %^{DEADLINE}t" :prepend t)
     ("n" "Notes" entry (file+headline "~/Dropbox/org/reference.org" "Notes")
      "* %?\n%U\n%a")
     ("b" "Business Ideas" entry (file+headline "~/Dropbox/org/reference.org" "Business Ideas")
      "* %^{one_word} %^G\nDescription: %^{Description}\nNotes: %?\n%U\n")
      ("m" "Meeting" entry (file+headline "~/Dropbox/org/index.org" "Meeting")
      "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
      ("p" "Phone call" entry (file+headline  "~/Dropbox/org/index.org" "Phone Calls")
      "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
      ("h" "Habit" entry (file+headline "~/Dropbox/org/index.org" "Habit")
      "* NEXT %?\n%U\n%a\nSCHEDULED: %(format-time-string \"%<<%Y-%m-%d %a .+1d/3d>>\")\n:PROPERTIES:\n:STYLE: habit\n:REPEAT_TO_STATE: NEXT\n:END:\n")   
      ))
#+end_src
** Org Refile
#+begin_src emacs-lisp
    (setq org-refile-targets
          '(
            ("~/Dropbox/org/reference.org" :level . 1)
            ("~/Dropbox/org/someday.org" :level . 1)
            ("~/Dropbox/org/tickler.org" :level . 1)
            ("~/Dropbox/org/project.org" :level . 1)
            ("~/Dropbox/org/now.org" :level . 1)
            ("~/Dropbox/org/waiting.org" :level . 1)
            ))
#+end_src
** Set Default Browser
#+begin_src emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "google-chrome")
#+end_src
** Open Pdf in Evince
#+begin_src emacs-lisp
(setq org-file-apps
      (append '(
                ("\\.pdf\\'" . "evince %s")
                ) org-file-apps ))
#+end_src
** Org Bullets
#+begin_src emacs-lisp
(use-package org-bullets
  :config
  (add-hook 'org-mode-hook
            (lambda () (org-bullets-mode 1))))
#+end_src
** Literate Programming
don't create a new window each time
#+begin_src emacs-lisp
(setq org-src-window-setup 'current-window)
#+end_src
use C-x C-s for closing out of the org-src-edit buffer
#+begin_src emacs-lisp
  (eval-after-load 'org-src
    '(define-key org-src-mode-map
       (kbd "C-x C-s") #'org-edit-src-exit))
#+end_src
** Org Gcal
#+begin_src emacs-lisp
(setq package-check-signature nil)

(use-package org-gcal
  :ensure t
  :config
  (setq org-gcal-client-id org_gcal_client_id
	org-gcal-client-secret org_gcal_client_secret
	org-gcal-file-alist '(("alamin.ineedahelp@gmail.com" .  "~/Dropbox/org/gcal.org"))))

(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync) ))
(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync) ))
#+end_src 
** Org Indent
#+BEGIN_SRC emacs-lisp
  (eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+END_SRC
** Org-Heading Customization
#+begin_src emacs-lisp
  (let* ((variable-tuple (cond ((x-list-fonts "Inconsolata") '(:font "Inconsolata"))
                             ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
                             ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
                             ((x-list-fonts "Verdana")         '(:font "Verdana"))
                             ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
                             (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
       (base-font-color     (face-foreground 'default nil 'default))
       (headline           `(:inherit default :weight bold :foreground ,base-font-color)))

  (custom-set-faces
   '(org-block-begin-line
     ((t (:foreground "#008ED1"))))
   '(org-block-background
     ((t (:background "#000000"))))
   '(org-block
     ((t (:background "#000000"))))
   '(org-block-end-line
     ((t (:foreground "#008ED1")))))

  (custom-theme-set-faces 'user
                          `(org-level-8 ((t (,@headline ,@variable-tuple))))
                          `(org-level-7 ((t (,@headline ,@variable-tuple))))
                          `(org-level-6 ((t (,@headline ,@variable-tuple))))
                          `(org-level-5 ((t (,@headline ,@variable-tuple))))
                          `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
                          `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25 :foreground "red"))))
                          `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5 :foreground "green"))))
                          `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75 :foreground "yellow"))))
                          `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))

#+end_src
* Programming
** General Settings
*** Paredit
[[http://danmidwood.com/content/2014/11/21/animated-paredit.html][Dan Midwood]] has a great guide to using
paredit.
#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :ensure t
    :diminish paredit-mode
    :config
    (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
    (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
    (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
    (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
    (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
    :bind (("C-c d" . paredit-forward-down))
    )

  ;; Ensure paredit is used EVERYWHERE!
  (use-package paredit-everywhere
    :ensure t
    :diminish paredit-everywhere-mode
    :config
    (add-hook 'prog-mode-hook #'paredit-everywhere-mode))

  (use-package highlight-parentheses
    :ensure t
    :diminish highlight-parentheses-mode
    :config
    (add-hook 'emacs-lisp-mode-hook
              (lambda()
                (highlight-parentheses-mode)
                )))

  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'lisp-mode-hook
              (lambda()
                (rainbow-delimiters-mode)
                )))

  (global-highlight-parentheses-mode)
#+END_SRC
** Emacs Lisp
*** ert
*** apropos
*** Key-bindings
#+begin_src emacs-lisp
  ;; (bind-key "C-c e b" 'do-eval-buffer)
  ;; (bind-key "C-c e e" 'toggle-debug-on-error)
  ;; (bind-key "C-c e f" 'emacs-lisp-byte-compile-and-load)
  ;; (bind-key "C-c e r" 'eval-region)
  ;; (bind-key "C-c e s" 'scratch)

  ;; (bind-key "C-h e" 'lisp-find-map)
  ;; (bind-key "C-h e e" 'view-echo-area-messages)
  ;; (bind-key "C-h e f" 'find-function)
  ;; (bind-key "C-h e k" 'find-function-on-key)
  ;; (bind-key "C-h e l" 'find-library)
  ;; (bind-key "C-h e v" 'find-variable)
  ;; (bind-key "C-h e V" 'apropos-value)
#+end_src
*** eval-expr
*** macrostep
** Python

IDE Features I will Need
- easily find files and switch between projects
- easy navigating through function definition
- contexual documentation
- inline help for function calls

Ref: [[https://youtu.be/6BlTGPsjGJk]]

*** init
#+begin_src emacs-lisp
  (add-hook 'python-mode-hook
            (lambda ()
              (setq indent-tabs-mode nil)
              (setq tab-width 4)
              (setq python-indent-offset 4)))

  (setq python-shell-interpreter "ipython3" python-shell-interpreter-args "--simple-prompt --pprint")

  ; switch to the interpreter after executing code
  (setq py-shell-switch-buffers-on-execute-p t)
  (setq py-switch-buffers-on-execute-p t)
  ; don't split windows
  (setq py-split-windows-on-execute-p nil)
  ; try to automagically figure out indentation
  (setq py-smart-indentation t)
#+end_src
#+begin_src bash
#sudo apt install -y python3-rope \
#                   python3-isort
#sudo pip3 install flake8 jedi autopep8 yapf importmagic
#+end_src
*** virtualenvwrapper
#+begin_src emacs-lisp
 (use-package virtualenvwrapper
   :ensure t
   :config
   (venv-initialize-interactive-shells)
   (venv-initialize-eshell))
#+end_src
*** elpy
#+begin_src emacs-lisp
  (use-package elpy
    :ensure t
    :commands elpy-enable
    :init (with-eval-after-load 'python3 (elpy-enable))

    :config
    (electric-indent-local-mode -1)
    (delete 'elpy-module-highlight-indentation elpy-modules)
    (delete 'elpy-module-flymake elpy-modules)

    (defun ha/elpy-goto-definition ()
      (interactive)
      (condition-case err
          (elpy-goto-definition)
        ('error (xref-find-definitions (symbol-name (symbol-at-point))))))

    :bind (:map elpy-mode-map ([remap elpy-goto-definition] .
                               ha/elpy-goto-definition)))

  (defalias 'workon 'pyvenv-workon)
#+end_src
*** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode t))
#+end_src
*** py-autopep8
#+begin_src emacs-lisp
 (use-package py-autopep8
 :ensure t
 :config
 (require 'py-autopep8)
 (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save))
#+end_src
*** anaconda
#+begin_src emacs-lisp
(use-package anaconda-mode
  :ensure t
  :init (add-hook 'python-mode-hook 'anaconda-mode)
        (add-hook 'python-mode-hook 'anaconda-eldoc-mode)
  :config (use-package company-anaconda
            :ensure t
            :init (add-hook 'python-mode-hook 'anaconda-mode)
            (eval-after-load "company"
              '(add-to-list 'company-backends '(company-anaconda :with company-capf)))))
#+end_src
*** jedi
#+begin_src emacs-lisp
(use-package jedi
  :ensure t
  :init
  (add-to-list 'company-backends 'company-jedi)
  :config
  (use-package company-jedi
    :ensure t
    :init
    (add-hook 'python-mode-hook (lambda () (add-to-list 'company-backends 'company-jedi)))
    (setq company-jedi-python-bin "python")))
#+end_src
** Latex
#+begin_src emacs-lis
;; latex
(use-package tex
:ensure auctex)

(defun tex-view ()
    (interactive)
    (tex-send-command "evince" (tex-append tex-print-file ".pdf")))
#+end_src
** Erlang                                                            :drill:
ref: purcell
#+begin_src emacs-lisp
  (use-package erlang
    :config
    (require 'erlang-start))
#+end_src
** JavaScript
ref: purcell
#+begin_src emacs-lisp

#+end_src
** C/C++
_Reference_: [[tuhdo1710@gmail.com]]
*** Features 
1. should be able to browse the Linux kernel source tree
inside Emacs effortlessly, such as jump to definition/references at
cursor, 
2. go back and forth between jumping points, 
3. finding any file
4. instantly, switching between .h and .c/.cpp.
*** Demos
A few demos:

- Switching between .h and .c/.cpp anywhere in the project like Linux
  kernel. If more than one file exists, it displays a list of
  possible candidates. The command collects files of the same names
  but different across the project:

[[file:static/c-ide/projectile-find-other-file.gif][file:static/c-ide/projectile-find-other-file.gif]]

- Jump around Linux kernel source with ease using =helm-gtags=. The
  demo begins when "START" appears at the bottom:

[[file:static/c-ide/helm-gtags-jump-dwim.gif][file:static/c-ide/helm-gtags-jump-dwim.gif]]

- Interactive outline tree using =moo-jump-local= from [[https://github.com/abo-abo/function-args][function-args]]
  package:

  [[file:static/c-ide/moo-jump-local.gif][file:static/c-ide/moo-jump-local.gif]]

- Static outline tree as a file browser:

[[file:static/c-ide/sr-speedbar.gif][file:static/c-ide/sr-speedbar.gif]]

- Symbol references:

[[file:static/c-ide/semantic-symref.gif][file:static/c-ide/semantic-symref.gif]]

- Code completion 1:

[[file:static/c-ide/semantic-boost-demo.gif][file:static/c-ide/semantic-boost-demo.gif]]

- Code completion 2:

[[file:static/auto_complete.gif][file:static/auto_complete.gif]]

- Header completion:

[[file:static/c-ide/company-c-header.png][file:static/c-ide/company-c-header.png]]

- Show function interface and variable definition at the bottom:

[[file:static/func_args.jpg][file:static/func_args.jpg]]

[[file:static/c-ide/semantic-idle-summary-lambda.gif][file:static/c-ide/semantic-idle-summary-lambda.gif]]

[[file:static/c-ide/semantic-idle-summary-variable.gif][file:static/c-ide/semantic-idle-summary-variable.gif]]


- Show current function your cursor is inside at the top:

[[file:static/c-ide/semantic-sticky-func.gif][file:static/c-ide/semantic-sticky-func.gif]]

- Compilation support:

[[file:static/c-ide/compilation-mode.gif][file:static/c-ide/compilation-mode.gif]]

- Beautiful compile output:

[[file:static/c-ide/compilation-compile.gif][file:static/c-ide/compilation-compile.gif]]

- Fancy GDB debugging:

[[file:static/c-ide/gdb-many-windows.gif][file:static/c-ide/gdb-many-windows.gif]]

- Getting man pages for symbol at cursor:

[[file:static/part3/helm-man-woman.gif][file:static/part3/helm-man-woman.gif]]

*** Source Code Navigation
**** Prerequisites
- Install helm + helm-gtags.
- Before using helm-gtags, remember to create a GTAGS database by running gtags at your project root in terminal:
#+begin_src shell-script
$ cd /path/to/project/root
$ gtags
#+end_src
- After this a few files are created
#+begin_src shell-script
$ ls G*
GPATH GRTAGS GTAGS
#+end_src

- GTAGS: definition database
- GRTAGS: reference database
- GPATH: path name database

**** Basic Movements
- *C-M-f* runs =forward-sexp=, move forward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/forward-func.gif][file:static/c-ide/forward-func.gif]]

- *C-M-b* runs =backward-sexp=, move backward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/backward-func.gif][file:static/c-ide/backward-func.gif]]

- *C-M-k* runs =kill-sexp=, kill balanced expression
  forward that can be a pair or a symbol. Demo:

  [[file:static/c-ide/kill-func-body.gif][file:static/c-ide/kill-func-body.gif]]

- *C-M-<SPC>* or *C-M-@* runs =mark-sexp=, put mark after
  following expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/mark-func-body.gif][file:static/c-ide/mark-func-body.gif]]

- *C-M-a* runs =beginning-of-defun=, which moves point to beginning of
  a function. Demo:

  [[file:static/c-ide/beginning-of-defun.gif][file:static/c-ide/beginning-of-defun.gif]]

- *C-M-e* runs =end-of-defun=, which moves point to end of a
  function. Demo:

  [[file:static/c-ide/end-of-defun.gif][file:static/c-ide/end-of-defun.gif]]

- *C-M-h* runs =mark-defun=, which put a region around whole current
  or following function. Demo:

  [[file:static/c-ide/mark-defun.gif][file:static/c-ide/mark-defun.gif]]
**** Find Definitions in current Buffer
**** Find References in Project
**** Find functions that current functions call
**** Find files in project
**** View visited tags with tag stack
*** Browse Source Tree with Speedbar File Browser
*** General Completion with =company-mode=
*** Demo Project
*** Source Code completion using Clang
*** Header file completion with =company-c-headers= Packages
*** CEDET
**** What is CEDET?
**** Why use CEDET?
**** Installation
**** Semantic minor modes
**** CEDET can do more
**** Source code navigation using Senator
**** Project Management with IDE
*** Code Refactoring
*** Navigate system include path
*** Project Management with Projectile
*** Source Code Information
*** Source Code Documentation
*** Source Code Formatting
*** Compilation Support
*** Debugging

* Applications
** Email
** Chat
** Docker
#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t)
#+end_src
* Blogging
* Writing
* Todo List [0%]
- [ ] Highlight and Narrowing [Howard]
- [ ] Org-Present
- [ ] Chatting
- [ ] Emailing
- [ ] A Secure Emacs Environment [Build Fun Things]
- [ ] Code Folding 
- [ ] Clojure Support [ Build Fun Things ]
- [ ] Rust Support [ Build Fun Things ]


